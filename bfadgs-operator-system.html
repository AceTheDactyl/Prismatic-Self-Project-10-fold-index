<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BFADGS Operator System | Closed Monoid Traversal</title>
    <style>
        :root {
            --bg-deep: #0a0a0f;
            --bg-mid: #12121a;
            --bg-light: #1a1a2e;
            --op-B: #3b82f6;
            --op-F: #10b981;
            --op-A: #f59e0b;
            --op-D: #ef4444;
            --op-G: #8b5cf6;
            --op-S: #ec4899;
            --text-primary: #e2e8f0;
            --text-dim: #94a3b8;
            --gold: #fbbf24;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: var(--bg-deep);
            color: var(--text-primary);
            min-height: 100vh;
            overflow-x: hidden;
        }

        /* Header */
        .header {
            text-align: center;
            padding: 60px 20px 40px;
            background: linear-gradient(180deg, var(--bg-light) 0%, var(--bg-deep) 100%);
            border-bottom: 1px solid rgba(255,255,255,0.05);
            position: relative;
            overflow: hidden;
        }

        .header::before {
            content: '';
            position: absolute;
            top: 0;
            left: 50%;
            transform: translateX(-50%);
            width: 600px;
            height: 300px;
            background: radial-gradient(ellipse, rgba(139,92,246,0.15) 0%, transparent 70%);
            pointer-events: none;
        }

        .header h1 {
            font-size: 3rem;
            font-weight: 300;
            letter-spacing: 0.3em;
            margin-bottom: 15px;
            background: linear-gradient(90deg, var(--op-B), var(--op-F), var(--op-A), var(--op-D), var(--op-G), var(--op-S));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .header .subtitle {
            font-size: 1.2rem;
            color: var(--text-dim);
            font-weight: 300;
        }

        .header .formula {
            margin-top: 25px;
            font-size: 1.5rem;
            font-family: 'Times New Roman', serif;
            color: var(--gold);
        }

        /* Main content */
        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 40px 20px;
        }

        /* Operator Cards */
        .operators-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 50px;
        }

        .operator-card {
            background: var(--bg-mid);
            border-radius: 12px;
            padding: 25px;
            text-align: center;
            border: 1px solid rgba(255,255,255,0.05);
            transition: all 0.3s ease;
            cursor: pointer;
        }

        .operator-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 40px rgba(0,0,0,0.3);
        }

        .operator-card.op-B { border-top: 3px solid var(--op-B); }
        .operator-card.op-F { border-top: 3px solid var(--op-F); }
        .operator-card.op-A { border-top: 3px solid var(--op-A); }
        .operator-card.op-D { border-top: 3px solid var(--op-D); }
        .operator-card.op-G { border-top: 3px solid var(--op-G); }
        .operator-card.op-S { border-top: 3px solid var(--op-S); }

        .operator-card .symbol {
            font-size: 3rem;
            font-weight: bold;
            margin-bottom: 10px;
        }

        .operator-card.op-B .symbol { color: var(--op-B); }
        .operator-card.op-F .symbol { color: var(--op-F); }
        .operator-card.op-A .symbol { color: var(--op-A); }
        .operator-card.op-D .symbol { color: var(--op-D); }
        .operator-card.op-G .symbol { color: var(--op-G); }
        .operator-card.op-S .symbol { color: var(--op-S); }

        .operator-card .name {
            font-size: 1.2rem;
            margin-bottom: 8px;
            color: var(--text-primary);
        }

        .operator-card .action {
            font-family: 'Times New Roman', serif;
            font-size: 1.1rem;
            color: var(--gold);
            margin-bottom: 10px;
        }

        .operator-card .description {
            font-size: 0.9rem;
            color: var(--text-dim);
            line-height: 1.5;
        }

        /* Section */
        .section {
            background: var(--bg-mid);
            border-radius: 16px;
            padding: 35px;
            margin-bottom: 30px;
            border: 1px solid rgba(255,255,255,0.05);
        }

        .section h2 {
            font-size: 1.8rem;
            font-weight: 400;
            margin-bottom: 25px;
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .section h2::before {
            content: '';
            width: 4px;
            height: 30px;
            background: linear-gradient(180deg, var(--op-G), var(--op-S));
            border-radius: 2px;
        }

        /* Algebraic Structure */
        .structure-box {
            background: var(--bg-light);
            border-radius: 12px;
            padding: 30px;
            text-align: center;
            margin-bottom: 25px;
        }

        .structure-box .main-formula {
            font-size: 2rem;
            font-family: 'Times New Roman', serif;
            color: var(--gold);
            margin-bottom: 20px;
        }

        .axioms {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }

        .axiom {
            background: var(--bg-deep);
            padding: 20px;
            border-radius: 8px;
            border-left: 3px solid var(--op-F);
        }

        .axiom .title {
            font-weight: 600;
            color: var(--op-F);
            margin-bottom: 8px;
        }

        .axiom .formula {
            font-family: 'Times New Roman', serif;
            font-size: 1.1rem;
            color: var(--text-primary);
        }

        /* Cayley Table */
        .cayley-container {
            overflow-x: auto;
        }

        .cayley-table {
            width: 100%;
            border-collapse: collapse;
            font-family: 'Times New Roman', serif;
            font-size: 1.1rem;
        }

        .cayley-table th,
        .cayley-table td {
            padding: 15px;
            text-align: center;
            border: 1px solid rgba(255,255,255,0.1);
        }

        .cayley-table th {
            background: var(--bg-light);
            font-weight: 600;
        }

        .cayley-table td {
            background: var(--bg-deep);
            transition: all 0.2s ease;
        }

        .cayley-table td:hover {
            background: rgba(139,92,246,0.2);
            transform: scale(1.05);
        }

        .cayley-table .header-B { color: var(--op-B); }
        .cayley-table .header-F { color: var(--op-F); }
        .cayley-table .header-A { color: var(--op-A); }
        .cayley-table .header-D { color: var(--op-D); }
        .cayley-table .header-G { color: var(--op-G); }
        .cayley-table .header-S { color: var(--op-S); }
        .cayley-table .header-I { color: var(--gold); }

        /* Closure Properties */
        .closure-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
        }

        .closure-item {
            background: var(--bg-light);
            padding: 25px;
            border-radius: 10px;
        }

        .closure-item h4 {
            color: var(--gold);
            margin-bottom: 12px;
            font-size: 1.1rem;
        }

        .closure-item .formula {
            font-family: 'Times New Roman', serif;
            font-size: 1.2rem;
            color: var(--text-primary);
            margin-bottom: 10px;
        }

        .closure-item p {
            color: var(--text-dim);
            font-size: 0.95rem;
            line-height: 1.6;
        }

        /* Traversal Canvas */
        .canvas-container {
            position: relative;
            background: var(--bg-deep);
            border-radius: 12px;
            overflow: hidden;
            margin-bottom: 25px;
        }

        #traversalCanvas {
            width: 100%;
            height: 500px;
            display: block;
        }

        .canvas-legend {
            position: absolute;
            top: 15px;
            right: 15px;
            background: rgba(10,10,15,0.9);
            padding: 15px;
            border-radius: 8px;
            font-size: 0.85rem;
        }

        .canvas-legend div {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 5px;
        }

        .legend-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
        }

        /* Calculator */
        .calculator {
            background: var(--bg-light);
            border-radius: 12px;
            padding: 30px;
        }

        .calc-display {
            background: var(--bg-deep);
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
            min-height: 80px;
            font-family: 'Courier New', monospace;
        }

        .calc-expression {
            font-size: 1.5rem;
            color: var(--gold);
            margin-bottom: 10px;
            word-wrap: break-word;
        }

        .calc-result {
            font-size: 1.1rem;
            color: var(--op-F);
        }

        .calc-buttons {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 10px;
        }

        .calc-btn {
            padding: 15px;
            border: none;
            border-radius: 8px;
            font-size: 1.2rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .calc-btn:hover {
            transform: scale(1.05);
        }

        .calc-btn.op-B { background: var(--op-B); color: white; }
        .calc-btn.op-F { background: var(--op-F); color: white; }
        .calc-btn.op-A { background: var(--op-A); color: black; }
        .calc-btn.op-D { background: var(--op-D); color: white; }
        .calc-btn.op-G { background: var(--op-G); color: white; }
        .calc-btn.op-S { background: var(--op-S); color: white; }
        .calc-btn.identity { background: var(--gold); color: black; }
        .calc-btn.action { background: rgba(255,255,255,0.1); color: var(--text-primary); }

        /* Traversal Semantics */
        .semantics-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
            gap: 25px;
        }

        .semantic-card {
            background: var(--bg-light);
            border-radius: 10px;
            padding: 25px;
            position: relative;
            overflow: hidden;
        }

        .semantic-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 3px;
            background: linear-gradient(90deg, var(--op-B), var(--op-S));
        }

        .semantic-card h4 {
            color: var(--text-primary);
            margin-bottom: 15px;
            font-size: 1.1rem;
        }

        .semantic-card .path {
            font-family: 'Times New Roman', serif;
            font-size: 1.3rem;
            color: var(--gold);
            margin-bottom: 15px;
            text-align: center;
            padding: 15px;
            background: var(--bg-deep);
            border-radius: 8px;
        }

        .semantic-card p {
            color: var(--text-dim);
            line-height: 1.6;
        }

        /* Graph Algorithms */
        .algorithm-box {
            background: var(--bg-deep);
            border-radius: 10px;
            padding: 25px;
            margin-bottom: 20px;
            border-left: 4px solid var(--op-G);
        }

        .algorithm-box h4 {
            color: var(--op-G);
            margin-bottom: 15px;
        }

        .algorithm-box pre {
            font-family: 'Courier New', monospace;
            font-size: 0.95rem;
            line-height: 1.8;
            color: var(--text-primary);
            overflow-x: auto;
        }

        .algorithm-box .keyword { color: var(--op-S); }
        .algorithm-box .operator { color: var(--gold); }
        .algorithm-box .comment { color: var(--text-dim); }

        /* Inverse Relations Diagram */
        .inverse-diagram {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 40px;
            flex-wrap: wrap;
            padding: 30px;
            background: var(--bg-deep);
            border-radius: 12px;
            margin-bottom: 20px;
        }

        .inverse-pair {
            text-align: center;
            padding: 25px;
            background: var(--bg-light);
            border-radius: 10px;
            min-width: 180px;
        }

        .inverse-pair .ops {
            font-size: 2rem;
            font-weight: bold;
            margin-bottom: 10px;
        }

        .inverse-pair .relation {
            font-family: 'Times New Roman', serif;
            font-size: 1.2rem;
            color: var(--gold);
        }

        /* State Diagram */
        .state-flow {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 20px;
            padding: 40px;
            background: var(--bg-deep);
            border-radius: 12px;
            flex-wrap: wrap;
        }

        .state-node {
            width: 80px;
            height: 80px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
            font-weight: bold;
            border: 3px solid;
        }

        .state-alpha {
            background: linear-gradient(135deg, var(--op-B), var(--op-F));
            border-color: var(--op-B);
        }

        .state-omega {
            background: linear-gradient(135deg, var(--op-S), var(--op-G));
            border-color: var(--op-S);
        }

        .state-arrow {
            font-size: 2rem;
            color: var(--gold);
        }

        .state-ops {
            font-size: 0.9rem;
            color: var(--text-dim);
            text-align: center;
        }

        /* Footer */
        .footer {
            text-align: center;
            padding: 40px;
            color: var(--text-dim);
            font-size: 0.9rem;
        }

        .footer .monoid-signature {
            font-family: 'Times New Roman', serif;
            font-size: 1.3rem;
            color: var(--gold);
            margin-bottom: 15px;
        }

        /* Responsive */
        @media (max-width: 768px) {
            .header h1 {
                font-size: 2rem;
                letter-spacing: 0.1em;
            }

            .operators-grid {
                grid-template-columns: repeat(2, 1fr);
            }

            .calc-buttons {
                grid-template-columns: repeat(2, 1fr);
            }

            .inverse-diagram {
                flex-direction: column;
            }
        }
    </style>
</head>
<body>
    <header class="header">
        <h1>BFADGS</h1>
        <p class="subtitle">Closed Monoid Operator System for Graph Traversal</p>
        <div class="formula">⟨B, F, A, D, G, S | e⟩ : α → ω</div>
    </header>

    <div class="container">
        <!-- Operator Cards -->
        <section class="operators-grid">
            <div class="operator-card op-B" onclick="addOperator('B')">
                <div class="symbol">B</div>
                <div class="name">Begin</div>
                <div class="action">∅ → I²</div>
                <div class="description">Initialize state from void. The genesis operator that creates initial structure.</div>
            </div>
            <div class="operator-card op-F" onclick="addOperator('F')">
                <div class="symbol">F</div>
                <div class="name">Flow</div>
                <div class="action">x → φ·x</div>
                <div class="description">Traverse edge by golden ratio. Propagates state through connections.</div>
            </div>
            <div class="operator-card op-A" onclick="addOperator('A')">
                <div class="symbol">A</div>
                <div class="name">Ascend</div>
                <div class="action">n → n+1</div>
                <div class="description">Increase depth level. Move toward abstraction and higher-order structure.</div>
            </div>
            <div class="operator-card op-D" onclick="addOperator('D')">
                <div class="symbol">D</div>
                <div class="name">Descend</div>
                <div class="action">n → n-1</div>
                <div class="description">Decrease depth level. Move toward concretion and lower-order detail.</div>
            </div>
            <div class="operator-card op-G" onclick="addOperator('G')">
                <div class="symbol">G</div>
                <div class="name">Generate</div>
                <div class="action">x → {x, x'}</div>
                <div class="description">Spawn branch from node. Creates bifurcation and parallel paths.</div>
            </div>
            <div class="operator-card op-S" onclick="addOperator('S')">
                <div class="symbol">S</div>
                <div class="name">Synthesize</div>
                <div class="action">{a,b} → a⊕b</div>
                <div class="description">Merge divergent paths. Unifies branches through symmetric difference.</div>
            </div>
        </section>

        <!-- Algebraic Structure -->
        <section class="section">
            <h2>Algebraic Structure</h2>
            <div class="structure-box">
                <div class="main-formula">⟨{B, F, A, D, G, S}, ∘, e⟩ ≅ Closed Monoid M₆</div>
            </div>

            <div class="axioms">
                <div class="axiom">
                    <div class="title">Closure</div>
                    <div class="formula">∀x,y ∈ M₆ : x ∘ y ∈ M₆</div>
                </div>
                <div class="axiom">
                    <div class="title">Associativity</div>
                    <div class="formula">(x ∘ y) ∘ z = x ∘ (y ∘ z)</div>
                </div>
                <div class="axiom">
                    <div class="title">Identity</div>
                    <div class="formula">∃e : e ∘ x = x ∘ e = x</div>
                </div>
                <div class="axiom">
                    <div class="title">Generator Set</div>
                    <div class="formula">M₆ = ⟨B,F,A,D,G,S⟩*</div>
                </div>
            </div>
        </section>

        <!-- Interactive Canvas -->
        <section class="section">
            <h2>Traversal Visualization</h2>
            <div class="canvas-container">
                <canvas id="traversalCanvas"></canvas>
                <div class="canvas-legend">
                    <div><span class="legend-dot" style="background: var(--op-B)"></span> Begin</div>
                    <div><span class="legend-dot" style="background: var(--op-F)"></span> Flow</div>
                    <div><span class="legend-dot" style="background: var(--op-A)"></span> Ascend</div>
                    <div><span class="legend-dot" style="background: var(--op-D)"></span> Descend</div>
                    <div><span class="legend-dot" style="background: var(--op-G)"></span> Generate</div>
                    <div><span class="legend-dot" style="background: var(--op-S)"></span> Synthesize</div>
                </div>
            </div>
            <div style="text-align: center; color: var(--text-dim); margin-top: 15px;">
                Click operators above or use the calculator below to visualize traversal paths
            </div>
        </section>

        <!-- Cayley Table -->
        <section class="section">
            <h2>Cayley Table: Operator Compositions</h2>
            <p style="color: var(--text-dim); margin-bottom: 20px;">
                The composition table defines how operators combine. Each cell shows the result of (row ∘ column).
            </p>
            <div class="cayley-container">
                <table class="cayley-table">
                    <thead>
                        <tr>
                            <th>∘</th>
                            <th class="header-I">e</th>
                            <th class="header-B">B</th>
                            <th class="header-F">F</th>
                            <th class="header-A">A</th>
                            <th class="header-D">D</th>
                            <th class="header-G">G</th>
                            <th class="header-S">S</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <th class="header-I">e</th>
                            <td>e</td>
                            <td style="color: var(--op-B)">B</td>
                            <td style="color: var(--op-F)">F</td>
                            <td style="color: var(--op-A)">A</td>
                            <td style="color: var(--op-D)">D</td>
                            <td style="color: var(--op-G)">G</td>
                            <td style="color: var(--op-S)">S</td>
                        </tr>
                        <tr>
                            <th class="header-B">B</th>
                            <td style="color: var(--op-B)">B</td>
                            <td style="color: var(--op-B)">B</td>
                            <td style="color: var(--op-F)">BF</td>
                            <td style="color: var(--op-A)">BA</td>
                            <td style="color: var(--op-D)">BD</td>
                            <td style="color: var(--op-G)">BG</td>
                            <td style="color: var(--gold)">e</td>
                        </tr>
                        <tr>
                            <th class="header-F">F</th>
                            <td style="color: var(--op-F)">F</td>
                            <td style="color: var(--op-B)">FB</td>
                            <td style="color: var(--op-F)">F²</td>
                            <td style="color: var(--op-A)">FA</td>
                            <td style="color: var(--op-D)">FD</td>
                            <td style="color: var(--op-G)">FG</td>
                            <td style="color: var(--op-S)">FS</td>
                        </tr>
                        <tr>
                            <th class="header-A">A</th>
                            <td style="color: var(--op-A)">A</td>
                            <td style="color: var(--op-B)">AB</td>
                            <td style="color: var(--op-F)">AF</td>
                            <td style="color: var(--op-A)">A²</td>
                            <td style="color: var(--gold)">e</td>
                            <td style="color: var(--op-G)">AG</td>
                            <td style="color: var(--op-S)">AS</td>
                        </tr>
                        <tr>
                            <th class="header-D">D</th>
                            <td style="color: var(--op-D)">D</td>
                            <td style="color: var(--op-B)">DB</td>
                            <td style="color: var(--op-F)">DF</td>
                            <td style="color: var(--gold)">e</td>
                            <td style="color: var(--op-D)">D²</td>
                            <td style="color: var(--op-G)">DG</td>
                            <td style="color: var(--op-S)">DS</td>
                        </tr>
                        <tr>
                            <th class="header-G">G</th>
                            <td style="color: var(--op-G)">G</td>
                            <td style="color: var(--op-B)">GB</td>
                            <td style="color: var(--op-F)">GF</td>
                            <td style="color: var(--op-A)">GA</td>
                            <td style="color: var(--op-D)">GD</td>
                            <td style="color: var(--op-G)">G²</td>
                            <td style="color: var(--gold)">e</td>
                        </tr>
                        <tr>
                            <th class="header-S">S</th>
                            <td style="color: var(--op-S)">S</td>
                            <td style="color: var(--gold)">e</td>
                            <td style="color: var(--op-F)">SF</td>
                            <td style="color: var(--op-A)">SA</td>
                            <td style="color: var(--op-D)">SD</td>
                            <td style="color: var(--gold)">e</td>
                            <td style="color: var(--op-S)">S²</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div style="margin-top: 20px; padding: 20px; background: var(--bg-light); border-radius: 8px;">
                <p style="color: var(--text-dim); font-size: 0.95rem;">
                    <strong style="color: var(--gold);">Key Observations:</strong><br>
                    - A·D = D·A = e (Ascend and Descend are inverses)<br>
                    - B·S = S·B = e (Begin and Synthesize close the loop)<br>
                    - G·S = S·G = e (Generate and Synthesize are complementary)<br>
                    - F² represents double-flow (φ² = φ + 1 by golden ratio property)
                </p>
            </div>
        </section>

        <!-- Closure Properties -->
        <section class="section">
            <h2>Closure Properties</h2>
            <div class="closure-grid">
                <div class="closure-item">
                    <h4>Compositional Closure</h4>
                    <div class="formula">∀OP₁, OP₂ ∈ BFADGS : OP₁ ∘ OP₂ ∈ BFADGS*</div>
                    <p>Any sequence of operators produces a valid traversal within the system's state space.</p>
                </div>
                <div class="closure-item">
                    <h4>Path Closure</h4>
                    <div class="formula">Path(α, ω) ⊆ {BFADGS}*</div>
                    <p>Every path from origin (α) to terminus (ω) is expressible as a word in the operator alphabet.</p>
                </div>
                <div class="closure-item">
                    <h4>Level Closure</h4>
                    <div class="formula">A^n ∘ D^n = D^n ∘ A^n = e</div>
                    <p>Ascending and descending the same number of levels returns to the original depth.</p>
                </div>
                <div class="closure-item">
                    <h4>Branch Closure</h4>
                    <div class="formula">S ∘ G^n = G^(n-1), S^n ∘ G^n = e</div>
                    <p>Synthesis reduces branching; equal generate-synthesize pairs close to identity.</p>
                </div>
                <div class="closure-item">
                    <h4>Flow Periodicity</h4>
                    <div class="formula">F^∞ = lim(φⁿ) mod Ω</div>
                    <p>Repeated flow converges or cycles within the bounded state space Ω.</p>
                </div>
                <div class="closure-item">
                    <h4>Genesis-Terminus Duality</h4>
                    <div class="formula">B ⊣ S : ∅ ↔ Ω</div>
                    <p>Begin and Synthesize form an adjoint pair connecting void and complete states.</p>
                </div>
            </div>
        </section>

        <!-- Inverse Relations -->
        <section class="section">
            <h2>Inverse Relations</h2>
            <div class="inverse-diagram">
                <div class="inverse-pair">
                    <div class="ops">
                        <span style="color: var(--op-A)">A</span> ·
                        <span style="color: var(--op-D)">D</span>
                    </div>
                    <div class="relation">= e (identity on levels)</div>
                </div>
                <div class="inverse-pair">
                    <div class="ops">
                        <span style="color: var(--op-D)">D</span> ·
                        <span style="color: var(--op-A)">A</span>
                    </div>
                    <div class="relation">= e (symmetric inverse)</div>
                </div>
                <div class="inverse-pair">
                    <div class="ops">
                        <span style="color: var(--op-B)">B</span> ·
                        <span style="color: var(--op-S)">S</span>
                    </div>
                    <div class="relation">= e (α-ω closure)</div>
                </div>
                <div class="inverse-pair">
                    <div class="ops">
                        <span style="color: var(--op-G)">G</span> ·
                        <span style="color: var(--op-S)">S</span>
                    </div>
                    <div class="relation">= e (branch closure)</div>
                </div>
            </div>

            <div class="state-flow">
                <div class="state-node state-alpha">α</div>
                <div>
                    <div class="state-arrow">→ B·F·A·G →</div>
                    <div class="state-ops">expansion phase</div>
                </div>
                <div style="width: 60px; height: 60px; border-radius: 50%; background: var(--bg-light); display: flex; align-items: center; justify-content: center; color: var(--gold);">I²</div>
                <div>
                    <div class="state-arrow">→ S·D·F·S →</div>
                    <div class="state-ops">synthesis phase</div>
                </div>
                <div class="state-node state-omega">ω</div>
            </div>
        </section>

        <!-- Traversal Semantics -->
        <section class="section">
            <h2>Traversal Semantics: α → ω Space</h2>
            <div class="semantics-grid">
                <div class="semantic-card">
                    <h4>Depth-First Traversal</h4>
                    <div class="path">B → (A → F)* → (D → F)* → S</div>
                    <p>Descend fully before backtracking. The pattern A→F explores depth while D→F returns through siblings.</p>
                </div>
                <div class="semantic-card">
                    <h4>Breadth-First Traversal</h4>
                    <div class="path">B → (F → G)* → S*</div>
                    <p>Flow across level before descending. Generate creates the frontier, Synthesize collapses visited nodes.</p>
                </div>
                <div class="semantic-card">
                    <h4>Golden Spiral Path</h4>
                    <div class="path">B → (F^φ → A)* → ω</div>
                    <p>Flow by golden ratio steps with periodic ascension. Creates logarithmic spiral traversal pattern.</p>
                </div>
                <div class="semantic-card">
                    <h4>Binary Tree Walk</h4>
                    <div class="path">B → (G → A → F → D → F)* → S*</div>
                    <p>Generate two children, explore left (ascend-flow), return (descend-flow), synthesize at root.</p>
                </div>
                <div class="semantic-card">
                    <h4>Convergent Synthesis</h4>
                    <div class="path">G^n → F* → S^n</div>
                    <p>Maximum branching followed by parallel flow and complete synthesis. The system converges to unity.</p>
                </div>
                <div class="semantic-card">
                    <h4>Level-Order Scan</h4>
                    <div class="path">B → (F* → D → G)* → A* → S</div>
                    <p>Complete each level (F*), descend one (D), generate next level (G), finally ascend all and synthesize.</p>
                </div>
            </div>
        </section>

        <!-- Graph Algorithms -->
        <section class="section">
            <h2>Connection to Graph Algorithms</h2>
            <div class="algorithm-box">
                <h4>BFADGS-DFS (Depth-First Search)</h4>
                <pre><span class="keyword">function</span> DFS(node):
    <span class="operator">B</span>(node)                    <span class="comment">// Initialize at node</span>
    <span class="keyword">for each</span> child <span class="keyword">in</span> children(node):
        <span class="operator">A</span>                         <span class="comment">// Ascend to child level</span>
        <span class="operator">F</span>(child)                  <span class="comment">// Flow to child</span>
        DFS(child)                <span class="comment">// Recursive descent</span>
        <span class="operator">D</span>                         <span class="comment">// Descend back</span>
    <span class="operator">S</span>(node)                    <span class="comment">// Synthesize results</span></pre>
            </div>

            <div class="algorithm-box">
                <h4>BFADGS-BFS (Breadth-First Search)</h4>
                <pre><span class="keyword">function</span> BFS(root):
    queue = [<span class="operator">B</span>(root)]         <span class="comment">// Begin with root</span>
    <span class="keyword">while</span> queue not empty:
        current = queue.pop()
        <span class="keyword">for each</span> neighbor <span class="keyword">in</span> adjacent(current):
            <span class="operator">F</span>(neighbor)           <span class="comment">// Flow to neighbor</span>
            <span class="operator">G</span>                     <span class="comment">// Generate frontier node</span>
            queue.push(neighbor)
    <span class="operator">S</span>*                        <span class="comment">// Synthesize all paths</span></pre>
            </div>

            <div class="algorithm-box">
                <h4>BFADGS-Dijkstra (Weighted Shortest Path)</h4>
                <pre><span class="keyword">function</span> Dijkstra(source, target):
    <span class="operator">B</span>(source)                  <span class="comment">// Initialize at source</span>
    priority_queue = [(0, source)]
    <span class="keyword">while</span> current ≠ target:
        (dist, current) = queue.min()
        <span class="keyword">for each</span> (neighbor, weight) <span class="keyword">in</span> edges(current):
            <span class="operator">F</span>^weight(neighbor)    <span class="comment">// Flow weighted by edge</span>
            <span class="keyword">if</span> improved:
                <span class="operator">G</span>                 <span class="comment">// Generate better path</span>
    <span class="operator">S</span>(path)                    <span class="comment">// Synthesize optimal path</span></pre>
            </div>
        </section>

        <!-- Operator Calculator -->
        <section class="section">
            <h2>Interactive Operator Composition</h2>
            <div class="calculator">
                <div class="calc-display">
                    <div class="calc-expression" id="expression">e</div>
                    <div class="calc-result" id="result">Identity element</div>
                </div>
                <div class="calc-buttons">
                    <button class="calc-btn op-B" onclick="addOperator('B')">B</button>
                    <button class="calc-btn op-F" onclick="addOperator('F')">F</button>
                    <button class="calc-btn op-A" onclick="addOperator('A')">A</button>
                    <button class="calc-btn op-D" onclick="addOperator('D')">D</button>
                    <button class="calc-btn op-G" onclick="addOperator('G')">G</button>
                    <button class="calc-btn op-S" onclick="addOperator('S')">S</button>
                    <button class="calc-btn identity" onclick="addOperator('e')">e</button>
                    <button class="calc-btn action" onclick="clearCalc()">Clear</button>
                    <button class="calc-btn action" onclick="simplify()">Simplify</button>
                    <button class="calc-btn action" onclick="undo()">Undo</button>
                    <button class="calc-btn action" onclick="evaluateTraversal()">Evaluate</button>
                    <button class="calc-btn action" onclick="randomPath()">Random</button>
                </div>
            </div>
        </section>
    </div>

    <footer class="footer">
        <div class="monoid-signature">M₆ = ⟨B, F, A, D, G, S | AD=DA=e, BS=SB=e, GS=e⟩</div>
        <p>The BFADGS Operator System | Closed Monoid Traversal Logic</p>
        <p style="margin-top: 10px; opacity: 0.7;">Every path through structure is a word in the operator language</p>
    </footer>

    <script>
        // Operator colors
        const opColors = {
            'B': '#3b82f6',
            'F': '#10b981',
            'A': '#f59e0b',
            'D': '#ef4444',
            'G': '#8b5cf6',
            'S': '#ec4899',
            'e': '#fbbf24'
        };

        // Calculator state
        let expression = [];
        let history = [];

        // Canvas setup
        const canvas = document.getElementById('traversalCanvas');
        const ctx = canvas.getContext('2d');
        let animationId = null;
        let nodes = [];
        let edges = [];
        let currentPath = [];
        let pathIndex = 0;

        function resizeCanvas() {
            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;
            initializeGraph();
        }

        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        function initializeGraph() {
            nodes = [];
            edges = [];

            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const levels = 4;
            const nodesPerLevel = [1, 3, 6, 10];

            let nodeId = 0;

            // Create nodes in tree structure
            for (let level = 0; level < levels; level++) {
                const count = nodesPerLevel[level];
                const y = 80 + level * 120;
                const startX = centerX - (count - 1) * 60;

                for (let i = 0; i < count; i++) {
                    nodes.push({
                        id: nodeId++,
                        x: startX + i * 120,
                        y: y,
                        level: level,
                        active: false,
                        label: level === 0 ? 'α' : (level === levels - 1 && i === Math.floor(count/2) ? 'ω' : '')
                    });
                }
            }

            // Create edges (tree connections)
            let prevStart = 0;
            let prevCount = nodesPerLevel[0];

            for (let level = 1; level < levels; level++) {
                const currStart = prevStart + prevCount;
                const currCount = nodesPerLevel[level];

                for (let i = 0; i < currCount; i++) {
                    const parentIdx = prevStart + Math.floor(i * prevCount / currCount);
                    edges.push({
                        from: parentIdx,
                        to: currStart + i,
                        active: false
                    });
                }

                prevStart = currStart;
                prevCount = currCount;
            }

            draw();
        }

        function draw() {
            ctx.fillStyle = '#0a0a0f';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw grid
            ctx.strokeStyle = 'rgba(255,255,255,0.03)';
            ctx.lineWidth = 1;
            for (let x = 0; x < canvas.width; x += 40) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }
            for (let y = 0; y < canvas.height; y += 40) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }

            // Draw edges
            edges.forEach(edge => {
                const from = nodes[edge.from];
                const to = nodes[edge.to];

                ctx.beginPath();
                ctx.moveTo(from.x, from.y);
                ctx.lineTo(to.x, to.y);
                ctx.strokeStyle = edge.active ? opColors[edge.operator || 'F'] : 'rgba(255,255,255,0.15)';
                ctx.lineWidth = edge.active ? 3 : 1;
                ctx.stroke();

                if (edge.active) {
                    // Draw arrow
                    const angle = Math.atan2(to.y - from.y, to.x - from.x);
                    const midX = (from.x + to.x) / 2;
                    const midY = (from.y + to.y) / 2;

                    ctx.save();
                    ctx.translate(midX, midY);
                    ctx.rotate(angle);
                    ctx.beginPath();
                    ctx.moveTo(10, 0);
                    ctx.lineTo(-5, -6);
                    ctx.lineTo(-5, 6);
                    ctx.closePath();
                    ctx.fillStyle = opColors[edge.operator || 'F'];
                    ctx.fill();
                    ctx.restore();
                }
            });

            // Draw nodes
            nodes.forEach((node, idx) => {
                const gradient = ctx.createRadialGradient(node.x, node.y, 0, node.x, node.y, 25);

                if (node.active) {
                    gradient.addColorStop(0, opColors[node.operator || 'G']);
                    gradient.addColorStop(1, 'rgba(0,0,0,0.5)');
                } else {
                    gradient.addColorStop(0, '#2a2a3e');
                    gradient.addColorStop(1, '#1a1a2e');
                }

                ctx.beginPath();
                ctx.arc(node.x, node.y, 20, 0, Math.PI * 2);
                ctx.fillStyle = gradient;
                ctx.fill();
                ctx.strokeStyle = node.active ? opColors[node.operator || 'G'] : 'rgba(255,255,255,0.2)';
                ctx.lineWidth = 2;
                ctx.stroke();

                // Draw label
                if (node.label) {
                    ctx.fillStyle = '#fbbf24';
                    ctx.font = 'bold 16px serif';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(node.label, node.x, node.y);
                }
            });

            // Draw current expression
            if (expression.length > 0) {
                ctx.fillStyle = 'rgba(10,10,15,0.8)';
                ctx.fillRect(10, canvas.height - 50, 200, 40);
                ctx.fillStyle = '#fbbf24';
                ctx.font = '16px monospace';
                ctx.textAlign = 'left';
                ctx.textBaseline = 'middle';
                ctx.fillText('Path: ' + expression.join(' ∘ '), 20, canvas.height - 30);
            }
        }

        function animateTraversal() {
            if (pathIndex >= currentPath.length) {
                pathIndex = 0;
                return;
            }

            const op = currentPath[pathIndex];

            // Reset previous states
            nodes.forEach(n => n.active = false);
            edges.forEach(e => e.active = false);

            // Apply operator visualization
            switch(op) {
                case 'B':
                    nodes[0].active = true;
                    nodes[0].operator = 'B';
                    break;
                case 'F':
                    // Flow - activate random edge
                    const flowEdge = edges[Math.floor(Math.random() * edges.length)];
                    flowEdge.active = true;
                    flowEdge.operator = 'F';
                    nodes[flowEdge.to].active = true;
                    nodes[flowEdge.to].operator = 'F';
                    break;
                case 'A':
                    // Ascend - move up levels
                    const ascendNode = nodes.filter(n => n.level > 0)[Math.floor(Math.random() * 10) % nodes.filter(n => n.level > 0).length];
                    if (ascendNode) {
                        ascendNode.active = true;
                        ascendNode.operator = 'A';
                    }
                    break;
                case 'D':
                    // Descend - move down levels
                    const descendNode = nodes.filter(n => n.level < 3)[Math.floor(Math.random() * 10) % nodes.filter(n => n.level < 3).length];
                    if (descendNode) {
                        descendNode.active = true;
                        descendNode.operator = 'D';
                    }
                    break;
                case 'G':
                    // Generate - show branching
                    const genEdges = edges.slice(Math.floor(Math.random() * edges.length / 2), Math.floor(Math.random() * edges.length / 2) + 3);
                    genEdges.forEach(e => {
                        e.active = true;
                        e.operator = 'G';
                        nodes[e.to].active = true;
                        nodes[e.to].operator = 'G';
                    });
                    break;
                case 'S':
                    // Synthesize - converge to omega
                    const lastNode = nodes[nodes.length - Math.floor(nodes.length / 4)];
                    lastNode.active = true;
                    lastNode.operator = 'S';
                    break;
            }

            draw();
            pathIndex++;

            setTimeout(animateTraversal, 800);
        }

        // Calculator functions
        function addOperator(op) {
            history.push([...expression]);
            expression.push(op);
            updateDisplay();

            // Trigger animation
            currentPath = [...expression];
            pathIndex = 0;
            animateTraversal();
        }

        function clearCalc() {
            history.push([...expression]);
            expression = [];
            updateDisplay();
            nodes.forEach(n => n.active = false);
            edges.forEach(e => e.active = false);
            draw();
        }

        function undo() {
            if (history.length > 0) {
                expression = history.pop();
                updateDisplay();
            }
        }

        function simplify() {
            history.push([...expression]);

            // Apply simplification rules
            let simplified = expression.join('');

            // A·D = e and D·A = e
            while (simplified.includes('AD') || simplified.includes('DA')) {
                simplified = simplified.replace('AD', '').replace('DA', '');
            }

            // B·S = e and S·B = e
            while (simplified.includes('BS') || simplified.includes('SB')) {
                simplified = simplified.replace('BS', '').replace('SB', '');
            }

            // G·S = e
            while (simplified.includes('GS')) {
                simplified = simplified.replace('GS', '');
            }

            expression = simplified.length > 0 ? simplified.split('') : ['e'];
            updateDisplay();
        }

        function evaluateTraversal() {
            if (expression.length === 0) {
                expression = ['e'];
            }

            currentPath = [...expression];
            pathIndex = 0;
            animateTraversal();
        }

        function randomPath() {
            history.push([...expression]);
            const ops = ['B', 'F', 'A', 'D', 'G', 'S'];
            const length = 3 + Math.floor(Math.random() * 5);
            expression = [];

            // Start with B
            expression.push('B');

            for (let i = 1; i < length - 1; i++) {
                expression.push(ops[Math.floor(Math.random() * ops.length)]);
            }

            // End with S
            expression.push('S');

            updateDisplay();
            currentPath = [...expression];
            pathIndex = 0;
            animateTraversal();
        }

        function updateDisplay() {
            const exprEl = document.getElementById('expression');
            const resultEl = document.getElementById('result');

            if (expression.length === 0) {
                exprEl.textContent = 'e';
                resultEl.textContent = 'Identity element';
                return;
            }

            // Colorize expression
            exprEl.innerHTML = expression.map(op =>
                `<span style="color: ${opColors[op]}">${op}</span>`
            ).join(' ∘ ');

            // Analyze expression
            let analysis = [];

            const counts = {};
            expression.forEach(op => counts[op] = (counts[op] || 0) + 1);

            if (counts['A'] && counts['D']) {
                const pairs = Math.min(counts['A'], counts['D']);
                analysis.push(`${pairs} level-neutral pair(s)`);
            }

            if (counts['B'] && counts['S']) {
                analysis.push('α-ω complete path');
            }

            if (counts['G'] && counts['S']) {
                const pairs = Math.min(counts['G'], counts['S']);
                analysis.push(`${pairs} branch closure(s)`);
            }

            if (counts['F']) {
                analysis.push(`φ^${counts['F']} flow`);
            }

            resultEl.textContent = analysis.length > 0 ? analysis.join(' | ') : 'Operator sequence';
        }

        // Initialize
        updateDisplay();
    </script>
</body>
</html>
