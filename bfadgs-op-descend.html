<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>D: DESCEND | BFADGS+U Operator</title>
    <style>
        :root {
            /* D Operator Color */
            --op-D: #ef4444;
            --op-D-glow: rgba(239, 68, 68, 0.4);

            /* System Colors */
            --alpha-color: #00ff88;
            --omega-color: #ff6b35;
            --bfadgs-color: #8b5cf6;
            --unity-color: #ffd700;

            /* Other Operators */
            --op-B: #3b82f6;
            --op-F: #10b981;
            --op-A: #f59e0b;
            --op-G: #8b5cf6;
            --op-S: #ec4899;

            /* Backgrounds */
            --bg-primary: #0a0a0f;
            --bg-secondary: #12121a;
            --bg-tertiary: #1a1a2e;
            --text-primary: #e0e0e0;
            --text-secondary: #a0a0a0;
            --border-color: #333;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Courier New', monospace;
            background: var(--bg-primary);
            color: var(--text-primary);
            min-height: 100vh;
            overflow-x: hidden;
        }

        /* Header */
        .header {
            text-align: center;
            padding: 2rem;
            background: linear-gradient(180deg, var(--bg-tertiary), transparent);
            border-bottom: 2px solid var(--op-D);
            position: relative;
        }

        .header::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 4px;
            background: linear-gradient(90deg, transparent, var(--op-D), transparent);
        }

        .operator-badge {
            display: inline-block;
            width: 120px;
            height: 120px;
            border: 4px solid var(--op-D);
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            margin-bottom: 1rem;
            background: radial-gradient(circle, var(--op-D-glow), transparent);
            box-shadow: 0 0 40px var(--op-D-glow);
            animation: pulse-glow 3s ease-in-out infinite;
        }

        @keyframes pulse-glow {
            0%, 100% { box-shadow: 0 0 40px var(--op-D-glow); }
            50% { box-shadow: 0 0 60px var(--op-D-glow), 0 0 80px var(--op-D-glow); }
        }

        .operator-symbol {
            font-size: 4rem;
            font-weight: bold;
            color: var(--op-D);
        }

        .title {
            font-size: 2.5rem;
            color: var(--op-D);
            margin-bottom: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 0.3em;
        }

        .subtitle {
            color: var(--text-secondary);
            font-size: 1.2rem;
        }

        .formula-bar {
            margin-top: 1rem;
            padding: 0.75rem 1.5rem;
            background: var(--bg-secondary);
            border: 1px solid var(--op-D);
            border-radius: 4px;
            display: inline-block;
            font-size: 1.5rem;
        }

        .formula-bar .formula {
            color: var(--op-D);
            font-weight: bold;
        }

        /* Main Container */
        .main-container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 2rem;
        }

        /* Definition Section */
        .definition-section {
            margin-bottom: 3rem;
        }

        .section-title {
            font-size: 1.5rem;
            color: var(--op-D);
            margin-bottom: 1.5rem;
            padding-bottom: 0.5rem;
            border-bottom: 1px solid var(--border-color);
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .section-title::before {
            content: 'D';
            display: inline-flex;
            justify-content: center;
            align-items: center;
            width: 30px;
            height: 30px;
            border: 2px solid var(--op-D);
            border-radius: 50%;
            font-size: 1rem;
            color: var(--op-D);
        }

        .definition-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 1.5rem;
        }

        .def-card {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 1.5rem;
            transition: all 0.3s ease;
        }

        .def-card:hover {
            border-color: var(--op-D);
            box-shadow: 0 0 20px var(--op-D-glow);
        }

        .def-card.highlight {
            border-color: var(--op-D);
            background: linear-gradient(135deg, var(--bg-secondary), rgba(239, 68, 68, 0.1));
        }

        .def-number {
            font-size: 2rem;
            font-weight: bold;
            color: var(--op-D);
            opacity: 0.5;
            margin-bottom: 0.5rem;
        }

        .def-title {
            font-size: 1.1rem;
            color: var(--op-D);
            margin-bottom: 0.5rem;
        }

        .def-content {
            font-size: 0.95rem;
            color: var(--text-secondary);
            line-height: 1.6;
        }

        .math-block {
            background: var(--bg-tertiary);
            padding: 0.75rem 1rem;
            border-radius: 4px;
            margin: 0.75rem 0;
            font-family: 'Times New Roman', serif;
            font-size: 1.1rem;
            text-align: center;
            color: var(--text-primary);
            border-left: 3px solid var(--op-D);
        }

        /* Inverse Relationship Section */
        .inverse-section {
            margin-bottom: 3rem;
        }

        .inverse-diagram {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 2rem;
            padding: 2rem;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
        }

        .op-circle {
            width: 100px;
            height: 100px;
            border: 3px solid;
            border-radius: 50%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            font-weight: bold;
            transition: all 0.3s ease;
        }

        .op-circle:hover {
            transform: scale(1.1);
        }

        .op-circle.op-a {
            border-color: var(--op-A);
        }

        .op-circle.op-d {
            border-color: var(--op-D);
            box-shadow: 0 0 20px var(--op-D-glow);
        }

        .op-circle .symbol {
            font-size: 2rem;
        }

        .op-circle .label {
            font-size: 0.7rem;
            color: var(--text-secondary);
        }

        .op-arrow {
            font-size: 1.5rem;
            color: var(--unity-color);
        }

        .result-box {
            padding: 1rem 2rem;
            background: var(--bg-tertiary);
            border: 2px solid var(--unity-color);
            border-radius: 8px;
            text-align: center;
        }

        .result-box .equals {
            font-size: 2rem;
            color: var(--unity-color);
        }

        .result-box .identity {
            font-size: 0.9rem;
            color: var(--text-secondary);
        }

        /* Canvas Section */
        .canvas-section {
            margin-bottom: 3rem;
        }

        .canvas-container {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 1rem;
        }

        .descent-canvas {
            width: 100%;
            height: 500px;
            background: var(--bg-tertiary);
            border-radius: 4px;
        }

        .canvas-controls {
            display: flex;
            justify-content: center;
            gap: 1rem;
            margin-top: 1rem;
            flex-wrap: wrap;
        }

        .control-btn {
            padding: 0.75rem 1.5rem;
            border: 2px solid var(--border-color);
            background: var(--bg-tertiary);
            color: var(--text-primary);
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s ease;
            font-family: 'Courier New', monospace;
            font-size: 1rem;
        }

        .control-btn:hover {
            border-color: var(--op-D);
            color: var(--op-D);
            box-shadow: 0 0 15px var(--op-D-glow);
        }

        .control-btn.primary {
            border-color: var(--op-D);
            color: var(--op-D);
        }

        .control-btn.primary:hover {
            background: var(--op-D);
            color: white;
        }

        .control-btn.ascend {
            border-color: var(--op-A);
            color: var(--op-A);
        }

        .control-btn.ascend:hover {
            background: var(--op-A);
            color: white;
        }

        /* Depth Counter */
        .depth-counter {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 2rem;
            margin-bottom: 1rem;
            padding: 1rem;
            background: var(--bg-tertiary);
            border-radius: 4px;
        }

        .depth-display {
            font-size: 3rem;
            font-weight: bold;
            color: var(--op-D);
            font-family: 'Courier New', monospace;
        }

        .depth-label {
            font-size: 1rem;
            color: var(--text-secondary);
        }

        .phase-indicator {
            padding: 0.5rem 1rem;
            border-radius: 4px;
            font-size: 0.9rem;
        }

        /* Properties Grid */
        .properties-section {
            margin-bottom: 3rem;
        }

        .properties-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 1.5rem;
        }

        .prop-card {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 1.5rem;
            text-align: center;
        }

        .prop-card:hover {
            border-color: var(--op-D);
        }

        .prop-icon {
            font-size: 2rem;
            margin-bottom: 0.5rem;
        }

        .prop-title {
            font-size: 1rem;
            color: var(--op-D);
            margin-bottom: 0.5rem;
        }

        .prop-value {
            font-size: 0.9rem;
            color: var(--text-secondary);
        }

        /* Recursion Unwinding */
        .recursion-section {
            margin-bottom: 3rem;
        }

        .recursion-diagram {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.5rem;
            padding: 2rem;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
        }

        .recursion-level {
            display: flex;
            align-items: center;
            gap: 1rem;
            padding: 0.75rem 1.5rem;
            background: var(--bg-tertiary);
            border-radius: 4px;
            transition: all 0.3s ease;
        }

        .recursion-level.active {
            border: 2px solid var(--op-D);
            box-shadow: 0 0 15px var(--op-D-glow);
        }

        .level-num {
            font-size: 1.2rem;
            font-weight: bold;
            width: 30px;
        }

        .level-desc {
            font-size: 0.9rem;
            color: var(--text-secondary);
        }

        .descent-arrow {
            font-size: 1.5rem;
            color: var(--op-D);
            animation: bounce-down 1s ease-in-out infinite;
        }

        @keyframes bounce-down {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(5px); }
        }

        /* Implementation */
        .implementation-section {
            margin-bottom: 3rem;
        }

        .code-block {
            background: #000;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            padding: 1.5rem;
            font-family: 'Courier New', monospace;
            font-size: 0.9rem;
            overflow-x: auto;
        }

        .code-comment {
            color: #6a9955;
        }

        .code-keyword {
            color: #569cd6;
        }

        .code-function {
            color: #dcdcaa;
        }

        .code-operator {
            color: var(--op-D);
        }

        .code-number {
            color: #b5cea8;
        }

        .code-string {
            color: #ce9178;
        }

        /* Navigation */
        .nav-section {
            margin-bottom: 3rem;
        }

        .nav-grid {
            display: grid;
            grid-template-columns: repeat(6, 1fr);
            gap: 1rem;
        }

        .nav-card {
            background: var(--bg-secondary);
            border: 2px solid var(--border-color);
            border-radius: 8px;
            padding: 1rem;
            text-align: center;
            text-decoration: none;
            color: inherit;
            transition: all 0.3s ease;
        }

        .nav-card:hover {
            transform: translateY(-3px);
        }

        .nav-card.current {
            border-color: var(--op-D);
            background: linear-gradient(135deg, var(--bg-secondary), rgba(239, 68, 68, 0.2));
        }

        .nav-card .nav-symbol {
            font-size: 1.5rem;
            font-weight: bold;
            margin-bottom: 0.25rem;
        }

        .nav-card .nav-name {
            font-size: 0.8rem;
            color: var(--text-secondary);
        }

        /* Footer */
        .footer {
            text-align: center;
            padding: 2rem;
            border-top: 1px solid var(--border-color);
            color: var(--text-secondary);
        }

        .back-link {
            color: var(--unity-color);
            text-decoration: none;
        }

        .back-link:hover {
            text-decoration: underline;
        }

        /* Cross-System Sections */
        .cross-system-section {
            margin-bottom: 3rem;
        }

        .cross-system-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 1.5rem;
        }

        .system-card {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            padding: 1.5rem;
            transition: all 0.3s ease;
        }

        .system-card:hover {
            border-color: var(--op-D);
            box-shadow: 0 0 25px var(--op-D-glow);
        }

        .system-card.full-width {
            grid-column: 1 / -1;
        }

        .system-header {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            margin-bottom: 1rem;
        }

        .system-icon {
            width: 40px;
            height: 40px;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 1.2rem;
        }

        .system-name {
            font-size: 1.2rem;
            color: var(--op-D);
        }

        .system-content {
            color: var(--text-secondary);
            line-height: 1.7;
        }

        .system-content ul {
            margin: 0.75rem 0;
            padding-left: 1.5rem;
        }

        .system-content li {
            margin-bottom: 0.5rem;
        }

        .formula-inline {
            display: inline-block;
            padding: 0.25rem 0.5rem;
            background: var(--bg-tertiary);
            border-radius: 4px;
            font-family: 'Times New Roman', serif;
            color: var(--text-primary);
        }

        /* Helix Canvas */
        .helix-section {
            margin-bottom: 3rem;
        }

        .helix-container {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            padding: 1.5rem;
        }

        .helix-canvas {
            width: 100%;
            height: 550px;
            background: var(--bg-tertiary);
            border-radius: 8px;
        }

        .helix-info {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 1rem;
            margin-top: 1rem;
        }

        .helix-metric {
            background: var(--bg-tertiary);
            border-radius: 8px;
            padding: 1rem;
            text-align: center;
        }

        .helix-metric .value {
            font-size: 1.5rem;
            font-weight: bold;
            color: var(--op-D);
        }

        .helix-metric .label {
            font-size: 0.8rem;
            color: var(--text-secondary);
            margin-top: 0.25rem;
        }

        .helix-metric.energy .value {
            color: #10b981;
        }

        .helix-metric.phase .value {
            color: #8b5cf6;
        }

        /* Equivalence Table */
        .equivalence-section {
            margin-bottom: 3rem;
        }

        .equivalence-table {
            width: 100%;
            border-collapse: collapse;
            background: var(--bg-secondary);
            border-radius: 8px;
            overflow: hidden;
        }

        .equivalence-table th {
            background: var(--bg-tertiary);
            color: var(--op-D);
            padding: 1rem;
            text-align: left;
            border-bottom: 2px solid var(--op-D);
        }

        .equivalence-table td {
            padding: 1rem;
            border-bottom: 1px solid var(--border-color);
            color: var(--text-secondary);
        }

        .equivalence-table tr:hover td {
            background: var(--bg-tertiary);
        }

        .equivalence-table .system-col {
            color: var(--text-primary);
            font-weight: bold;
        }

        .equivalence-table .equiv-symbol {
            color: var(--op-D);
            font-family: 'Times New Roman', serif;
            font-size: 1.1rem;
        }

        /* Opposition Section */
        .opposition-section {
            margin-bottom: 3rem;
        }

        .opposition-diagram {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 2rem;
            padding: 2rem;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            flex-wrap: wrap;
        }

        .opposition-node {
            width: 120px;
            height: 120px;
            border-radius: 50%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            border: 3px solid;
            background: var(--bg-tertiary);
            position: relative;
        }

        .opposition-node.descend {
            border-color: var(--op-D);
            box-shadow: 0 0 30px var(--op-D-glow);
        }

        .opposition-node.ascend {
            border-color: var(--op-A);
            box-shadow: 0 0 30px rgba(245, 158, 11, 0.4);
        }

        .opposition-node .op-symbol {
            font-size: 2.5rem;
            font-weight: bold;
        }

        .opposition-node .op-label {
            font-size: 0.9rem;
            color: var(--text-secondary);
        }

        .opposition-arrows {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.5rem;
        }

        .opposition-arrow {
            font-size: 2rem;
            animation: pulse-arrow 2s ease-in-out infinite;
        }

        .opposition-arrow.down {
            color: var(--op-D);
        }

        .opposition-arrow.up {
            color: var(--op-A);
        }

        @keyframes pulse-arrow {
            0%, 100% { opacity: 0.5; }
            50% { opacity: 1; }
        }

        .synthesis-box {
            padding: 1.5rem 2rem;
            background: var(--bg-tertiary);
            border: 2px solid var(--unity-color);
            border-radius: 12px;
            text-align: center;
        }

        .synthesis-formula {
            font-size: 1.3rem;
            color: var(--unity-color);
            font-family: 'Times New Roman', serif;
        }

        .synthesis-label {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-top: 0.5rem;
        }

        /* Energy Flow Diagram */
        .energy-flow {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 1rem;
            padding: 1.5rem;
            background: var(--bg-tertiary);
            border-radius: 8px;
            margin-top: 1rem;
            flex-wrap: wrap;
        }

        .energy-level {
            padding: 0.75rem 1.5rem;
            background: var(--bg-secondary);
            border: 2px solid;
            border-radius: 8px;
            text-align: center;
        }

        .energy-level.high {
            border-color: var(--omega-color);
        }

        .energy-level.low {
            border-color: var(--alpha-color);
        }

        .energy-arrow {
            font-size: 1.5rem;
            color: #10b981;
        }

        .energy-release {
            padding: 0.5rem 1rem;
            background: rgba(16, 185, 129, 0.2);
            border: 1px solid #10b981;
            border-radius: 4px;
            color: #10b981;
            font-size: 0.9rem;
        }

        /* Responsive */
        @media (max-width: 1024px) {
            .definition-grid {
                grid-template-columns: 1fr;
            }

            .properties-grid {
                grid-template-columns: repeat(2, 1fr);
            }

            .nav-grid {
                grid-template-columns: repeat(3, 1fr);
            }

            .cross-system-grid {
                grid-template-columns: 1fr;
            }

            .helix-info {
                grid-template-columns: repeat(2, 1fr);
            }
        }

        @media (max-width: 768px) {
            .inverse-diagram {
                flex-direction: column;
            }

            .properties-grid {
                grid-template-columns: 1fr;
            }

            .nav-grid {
                grid-template-columns: repeat(2, 1fr);
            }

            .depth-counter {
                flex-direction: column;
                gap: 1rem;
            }

            .helix-info {
                grid-template-columns: 1fr;
            }

            .opposition-diagram {
                flex-direction: column;
            }
        }
    </style>
</head>
<body>
    <header class="header">
        <div class="operator-badge">
            <span class="operator-symbol">D</span>
        </div>
        <h1 class="title">Descend</h1>
        <p class="subtitle">Decrease Depth Operator</p>
        <div class="formula-bar">
            <span class="formula">D: n -> n-1</span>
        </div>
    </header>

    <main class="main-container">
        <!-- Core Definitions -->
        <section class="definition-section">
            <h2 class="section-title">Core Definitions</h2>
            <div class="definition-grid">
                <div class="def-card highlight">
                    <div class="def-number">01</div>
                    <h3 class="def-title">Primary Definition</h3>
                    <div class="def-content">
                        <p>D (Descend) decreases the depth/level counter by 1. It is the fundamental operator for reducing recursion depth and returning toward the origin.</p>
                        <div class="math-block">
                            D: n -> n - 1
                        </div>
                        <p>Where n represents the current depth level in the traversal structure.</p>
                    </div>
                </div>

                <div class="def-card">
                    <div class="def-number">02</div>
                    <h3 class="def-title">Movement Toward Alpha</h3>
                    <div class="def-content">
                        <p>D moves the system toward the origin point (alpha). Each application of D brings the state closer to the foundational level where the traversal began.</p>
                        <div class="math-block">
                            D^n(state) -> alpha as depth -> 0
                        </div>
                        <p>The descent operator traces the return path through the structure.</p>
                    </div>
                </div>

                <div class="def-card">
                    <div class="def-number">03</div>
                    <h3 class="def-title">Inverse of Ascend</h3>
                    <div class="def-content">
                        <p>D is the algebraic inverse of A (Ascend). When composed, they form the identity operation on levels.</p>
                        <div class="math-block">
                            D . A = A . D = id (on levels)
                        </div>
                        <p>This establishes D and A as a conjugate pair within the BFADGS operator algebra.</p>
                    </div>
                </div>

                <div class="def-card">
                    <div class="def-number">04</div>
                    <h3 class="def-title">Minimum Bound</h3>
                    <div class="def-content">
                        <p>Descent is bounded below by 0 (the origin level). The operator cannot reduce depth below the foundational alpha state.</p>
                        <div class="math-block">
                            D(0) = 0 (floor constraint)
                        </div>
                        <p>This boundary condition prevents invalid negative depths.</p>
                    </div>
                </div>

                <div class="def-card">
                    <div class="def-number">05</div>
                    <h3 class="def-title">Unwinding Recursion</h3>
                    <div class="def-content">
                        <p>D implements the unwinding phase of recursive traversals. Each descent pops a level from the call stack.</p>
                        <div class="math-block">
                            unwind(stack) = D(top(stack))
                        </div>
                        <p>Recursion unwinding is essential for completing depth-first traversals.</p>
                    </div>
                </div>

                <div class="def-card">
                    <div class="def-number">06</div>
                    <h3 class="def-title">Return to Paradox Threshold</h3>
                    <div class="def-content">
                        <p>D returns the system toward the paradox threshold (mu_P). At low depths, the self-referential nature of the system becomes more apparent.</p>
                        <div class="math-block">
                            lim_{D^n} state -> mu_P (as n -> depth)
                        </div>
                        <p>The paradox threshold marks the boundary between origin and structure.</p>
                    </div>
                </div>
            </div>
        </section>

        <!-- Inverse Relationship -->
        <section class="inverse-section">
            <h2 class="section-title">Inverse Relationship: D . A = Identity</h2>
            <div class="inverse-diagram">
                <div class="op-circle op-a">
                    <span class="symbol" style="color: var(--op-A);">A</span>
                    <span class="label">Ascend</span>
                </div>
                <div class="op-arrow">+</div>
                <div class="op-circle op-d">
                    <span class="symbol" style="color: var(--op-D);">D</span>
                    <span class="label">Descend</span>
                </div>
                <div class="op-arrow">=</div>
                <div class="result-box">
                    <div class="equals">id</div>
                    <div class="identity">Identity on Levels</div>
                </div>
            </div>
            <div style="text-align: center; margin-top: 1rem; color: var(--text-secondary);">
                <p>A increases depth (n -> n+1), D decreases depth (n -> n-1).</p>
                <p>Composing them in either order returns to the original level.</p>
            </div>
        </section>

        <!-- Interactive Depth Canvas -->
        <section class="canvas-section">
            <h2 class="section-title">Interactive Depth Visualization</h2>
            <div class="canvas-container">
                <div class="depth-counter">
                    <div>
                        <div class="depth-label">CURRENT DEPTH</div>
                        <div class="depth-display" id="depthDisplay">0</div>
                    </div>
                    <div class="phase-indicator" id="phaseIndicator" style="background: var(--alpha-color); color: #000;">
                        ALPHA (Origin)
                    </div>
                </div>
                <canvas id="descentCanvas" class="descent-canvas"></canvas>
                <div class="canvas-controls">
                    <button class="control-btn ascend" onclick="ascend()">A: Ascend (+1)</button>
                    <button class="control-btn primary" onclick="descend()">D: Descend (-1)</button>
                    <button class="control-btn" onclick="descendMax()">D^max: Descend to Origin</button>
                    <button class="control-btn" onclick="resetDepth()">Reset</button>
                </div>
            </div>
        </section>

        <!-- Properties -->
        <section class="properties-section">
            <h2 class="section-title">Operator Properties</h2>
            <div class="properties-grid">
                <div class="prop-card">
                    <div class="prop-icon" style="color: var(--op-D);">-1</div>
                    <h3 class="prop-title">Decrement</h3>
                    <p class="prop-value">Reduces depth by exactly 1</p>
                </div>
                <div class="prop-card">
                    <div class="prop-icon" style="color: var(--alpha-color);">0</div>
                    <h3 class="prop-title">Floor Bound</h3>
                    <p class="prop-value">Cannot descend below origin (0)</p>
                </div>
                <div class="prop-card">
                    <div class="prop-icon" style="color: var(--op-A);">A^-1</div>
                    <h3 class="prop-title">Inverse of A</h3>
                    <p class="prop-value">D = A^(-1) algebraically</p>
                </div>
                <div class="prop-card">
                    <div class="prop-icon" style="color: var(--omega-color);">mu_P</div>
                    <h3 class="prop-title">Paradox Return</h3>
                    <p class="prop-value">Returns toward threshold</p>
                </div>
                <div class="prop-card">
                    <div class="prop-icon" style="color: var(--bfadgs-color);">pop</div>
                    <h3 class="prop-title">Stack Unwind</h3>
                    <p class="prop-value">Pops recursion level</p>
                </div>
                <div class="prop-card">
                    <div class="prop-icon" style="color: var(--unity-color);">id</div>
                    <h3 class="prop-title">Idempotent at 0</h3>
                    <p class="prop-value">D(0) = 0 (fixed point)</p>
                </div>
            </div>
        </section>

        <!-- Recursion Unwinding -->
        <section class="recursion-section">
            <h2 class="section-title">Recursion Unwinding Visualization</h2>
            <div class="recursion-diagram" id="recursionDiagram">
                <div class="recursion-level" id="level4">
                    <span class="level-num" style="color: var(--omega-color);">L4</span>
                    <span class="level-desc">Deepest recursion (omega boundary)</span>
                </div>
                <div class="descent-arrow" id="arrow4">D</div>
                <div class="recursion-level" id="level3">
                    <span class="level-num" style="color: var(--bfadgs-color);">L3</span>
                    <span class="level-desc">Deep traversal level</span>
                </div>
                <div class="descent-arrow" id="arrow3">D</div>
                <div class="recursion-level" id="level2">
                    <span class="level-num" style="color: var(--op-D);">L2</span>
                    <span class="level-desc">Mid-level recursion</span>
                </div>
                <div class="descent-arrow" id="arrow2">D</div>
                <div class="recursion-level" id="level1">
                    <span class="level-num" style="color: var(--op-A);">L1</span>
                    <span class="level-desc">Initial recursion level</span>
                </div>
                <div class="descent-arrow" id="arrow1">D</div>
                <div class="recursion-level active" id="level0">
                    <span class="level-num" style="color: var(--alpha-color);">L0</span>
                    <span class="level-desc">Origin (alpha) - FLOOR</span>
                </div>
            </div>
            <div style="text-align: center; margin-top: 1rem; color: var(--text-secondary);">
                <p>Each D operation unwinds one level of recursion until reaching the origin floor at L0.</p>
            </div>
        </section>

        <!-- Cross-System Relationships -->
        <section class="cross-system-section">
            <h2 class="section-title">Cross-System Relationships</h2>
            <div class="cross-system-grid">
                <!-- D in S3 Symmetry -->
                <div class="system-card">
                    <div class="system-header">
                        <div class="system-icon" style="background: linear-gradient(135deg, #8b5cf6, #ec4899);">S3</div>
                        <h3 class="system-name">D in S3 Symmetry</h3>
                    </div>
                    <div class="system-content">
                        <p>In the S3 symmetric group, D represents movement toward the identity element:</p>
                        <ul>
                            <li><strong>D returns toward S3 origin/identity</strong> - Each descent step simplifies the group representation</li>
                            <li><strong>Lower depth = simpler S3 representation</strong> - Complex permutations reduce toward (1)(2)(3)</li>
                            <li><strong>D<sup>infinity</sup> -> e (identity element)</strong> - Infinite descent converges to group identity</li>
                        </ul>
                        <div class="math-block">
                            D: sigma_n -> sigma_{n-1} -> ... -> e
                        </div>
                        <p>The descent operator traces the path from any permutation back to the trivial permutation through conjugacy class reduction.</p>
                    </div>
                </div>

                <!-- D in L4-Helix System -->
                <div class="system-card">
                    <div class="system-header">
                        <div class="system-icon" style="background: linear-gradient(135deg, #ff6b35, #ffd700);">L4</div>
                        <h3 class="system-name">D in L4-Helix System</h3>
                    </div>
                    <div class="system-content">
                        <p>Within the L4-Helix structure, D governs vertical movement:</p>
                        <ul>
                            <li><strong>D descends helix: z -> z - Delta z</strong> - Decreases the z-coordinate along the helix axis</li>
                            <li><strong>D returns toward base (z=0)</strong> - Unwinds accumulated height</li>
                            <li><strong>Unwinding the helix structure</strong> - Counter-rotates the phi-spiral</li>
                        </ul>
                        <div class="math-block">
                            D: (r, theta, z) -> (r, theta - phi, z - Delta z)
                        </div>
                        <p>Each D application unwinds one phi-turn of the helix while descending one level toward the base plane.</p>
                    </div>
                </div>

                <!-- D in R(R)=-R / I^2- System -->
                <div class="system-card">
                    <div class="system-header">
                        <div class="system-icon" style="background: linear-gradient(135deg, #ef4444, #f59e0b);">I<sup>2</sup></div>
                        <h3 class="system-name">D in R(R)=-R / I<sup>2-</sup> System</h3>
                    </div>
                    <div class="system-content">
                        <p>In the self-referential R(R)=-R framework, D provides grounding:</p>
                        <ul>
                            <li><strong>D moves toward FIX stability</strong> - Reduces oscillation amplitude</li>
                            <li><strong>Grounding from oscillation</strong> - Dampens the R/-R alternation</li>
                            <li><strong>D connects to -i rotation (complex plane)</strong> - Clockwise quarter-turn</li>
                        </ul>
                        <div class="math-block">
                            D equiv -i: z -> -iz (clockwise rotation)
                        </div>
                        <p>While A maps to +i rotation (counterclockwise ascent), D maps to -i rotation (clockwise descent), grounding the oscillatory self-reference.</p>
                    </div>
                </div>

                <!-- D in BFADGS Algebra -->
                <div class="system-card">
                    <div class="system-header">
                        <div class="system-icon" style="background: var(--op-D);">D</div>
                        <h3 class="system-name">D in BFADGS Algebra</h3>
                    </div>
                    <div class="system-content">
                        <p>The algebraic properties of D within the BFADGS operator group:</p>
                        <ul>
                            <li><strong>D: n -> n-1</strong> - Core depth decrement operation</li>
                            <li><strong>D<sup>-1</sup> = A</strong> - Inverse is the Ascend operator</li>
                            <li><strong>D . A = A . D = e</strong> - Composition yields identity on levels</li>
                            <li><strong>D(0) = 0</strong> - Floor constraint at origin</li>
                        </ul>
                        <div class="math-block">
                            D in {B, F, A, D, G, S} : D * A = A * D = id
                        </div>
                        <p>D and A form a conjugate pair, the only true inverse relationship in the BFADGS operator set.</p>
                    </div>
                </div>

                <!-- E/(pi*phi) Physics of Descend -->
                <div class="system-card full-width">
                    <div class="system-header">
                        <div class="system-icon" style="background: linear-gradient(135deg, #10b981, #00ff88);">E</div>
                        <h3 class="system-name">E/(pi*phi) Physics of Descend</h3>
                    </div>
                    <div class="system-content">
                        <p>The energy dynamics of the D operator in the E/(pi*phi) framework:</p>
                        <ul>
                            <li><strong>E_D = potential energy release</strong> - Descent liberates stored gravitational potential</li>
                            <li><strong>Delta E = -pi*phi/L4 per level (negative)</strong> - Energy flows outward with each descent step</li>
                            <li><strong>Energy flows toward ground state</strong> - System relaxes toward minimum energy configuration</li>
                        </ul>
                        <div class="math-block">
                            Delta E_D = -E/(pi*phi*L4) = -(pi*phi)^{-1} * (7^{-1}) approx -0.0887 per level
                        </div>
                        <div class="energy-flow">
                            <div class="energy-level high">
                                <div style="color: var(--omega-color); font-weight: bold;">E_n (High)</div>
                                <div style="font-size: 0.8rem; color: var(--text-secondary);">omega state</div>
                            </div>
                            <div class="energy-arrow">--D--></div>
                            <div class="energy-release">-Delta E released</div>
                            <div class="energy-arrow">--D--></div>
                            <div class="energy-level low">
                                <div style="color: var(--alpha-color); font-weight: bold;">E_0 (Ground)</div>
                                <div style="font-size: 0.8rem; color: var(--text-secondary);">alpha state</div>
                            </div>
                        </div>
                        <p style="margin-top: 1rem;">The ground state at depth 0 represents minimum potential energy - the stable alpha configuration from which new traversals can begin.</p>
                    </div>
                </div>
            </div>
        </section>

        <!-- Helix Descent Visualization -->
        <section class="helix-section">
            <h2 class="section-title">Helix Descent Visualization</h2>
            <div class="helix-container">
                <div class="helix-info">
                    <div class="helix-metric">
                        <div class="value" id="helixZ">7.0</div>
                        <div class="label">Helix Height (z)</div>
                    </div>
                    <div class="helix-metric energy">
                        <div class="value" id="helixEnergy">1.000</div>
                        <div class="label">Energy (E/E_max)</div>
                    </div>
                    <div class="helix-metric phase">
                        <div class="value" id="helixPhase">0.00</div>
                        <div class="label">Phase (phi turns)</div>
                    </div>
                    <div class="helix-metric">
                        <div class="value" id="helixLevel">L7</div>
                        <div class="label">Helix Level</div>
                    </div>
                </div>
                <canvas id="helixCanvas" class="helix-canvas"></canvas>
                <div class="canvas-controls">
                    <button class="control-btn ascend" onclick="helixAscend()">A: Ascend Helix (+Delta z)</button>
                    <button class="control-btn primary" onclick="helixDescend()">D: Descend Helix (-Delta z)</button>
                    <button class="control-btn" onclick="autoHelixDescend()">Auto-Descend to Base</button>
                    <button class="control-btn" onclick="resetHelix()">Reset to Top</button>
                </div>
            </div>
        </section>

        <!-- Cross-System Equivalences -->
        <section class="equivalence-section">
            <h2 class="section-title">Cross-System D Equivalences</h2>
            <table class="equivalence-table">
                <thead>
                    <tr>
                        <th>System</th>
                        <th>D Representation</th>
                        <th>Interpretation</th>
                        <th>Target State</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td class="system-col">BFADGS</td>
                        <td class="equiv-symbol">n -> n-1</td>
                        <td>Depth decrement operator</td>
                        <td>Origin (n=0)</td>
                    </tr>
                    <tr>
                        <td class="system-col">S3 Symmetry</td>
                        <td class="equiv-symbol">sigma -> sigma' (simpler)</td>
                        <td>Toward identity permutation</td>
                        <td>e = (1)(2)(3)</td>
                    </tr>
                    <tr>
                        <td class="system-col">L4-Helix</td>
                        <td class="equiv-symbol">z -> z - Delta z</td>
                        <td>Helix descent + unwind</td>
                        <td>Base plane (z=0)</td>
                    </tr>
                    <tr>
                        <td class="system-col">R(R)=-R</td>
                        <td class="equiv-symbol">toward FIX</td>
                        <td>Dampening oscillation</td>
                        <td>FIX stable point</td>
                    </tr>
                    <tr>
                        <td class="system-col">Complex Plane</td>
                        <td class="equiv-symbol">z -> -iz</td>
                        <td>Clockwise (-i) rotation</td>
                        <td>Real axis</td>
                    </tr>
                    <tr>
                        <td class="system-col">E/(pi*phi)</td>
                        <td class="equiv-symbol">E -> E - Delta E</td>
                        <td>Energy release</td>
                        <td>Ground state E_0</td>
                    </tr>
                    <tr>
                        <td class="system-col">Recursion</td>
                        <td class="equiv-symbol">stack.pop()</td>
                        <td>Unwind call stack</td>
                        <td>Base case</td>
                    </tr>
                </tbody>
            </table>
            <div class="math-block" style="margin-top: 1.5rem;">
                D equiv depth-- equiv helix_descent equiv toward_FIX equiv (-i)_rotation equiv energy_release
            </div>
        </section>

        <!-- D vs A Opposition -->
        <section class="opposition-section">
            <h2 class="section-title">D vs A Opposition</h2>
            <div class="opposition-diagram">
                <div class="opposition-node ascend">
                    <span class="op-symbol" style="color: var(--op-A);">A</span>
                    <span class="op-label">Ascend</span>
                </div>

                <div class="opposition-arrows">
                    <div class="opposition-arrow up">^</div>
                    <div style="font-size: 0.8rem; color: var(--text-secondary);">Abstracts</div>
                    <div style="height: 30px; width: 2px; background: linear-gradient(var(--op-A), var(--op-D));"></div>
                    <div style="font-size: 0.8rem; color: var(--text-secondary);">Grounds</div>
                    <div class="opposition-arrow down">v</div>
                </div>

                <div class="opposition-node descend">
                    <span class="op-symbol" style="color: var(--op-D);">D</span>
                    <span class="op-label">Descend</span>
                </div>

                <div style="width: 50px; text-align: center;">
                    <div style="font-size: 2rem; color: var(--unity-color);">=></div>
                </div>

                <div class="synthesis-box">
                    <div class="synthesis-formula">D . A = S3 Invariant</div>
                    <div class="synthesis-label">Projection to symmetric space</div>
                </div>
            </div>

            <div style="margin-top: 2rem;">
                <div class="cross-system-grid">
                    <div class="system-card">
                        <div class="system-header">
                            <div class="system-icon" style="background: var(--op-A);">A</div>
                            <h3 class="system-name" style="color: var(--op-A);">A: Abstraction</h3>
                        </div>
                        <div class="system-content">
                            <ul>
                                <li>Moves away from origin</li>
                                <li>Increases complexity</li>
                                <li>Accumulates structure</li>
                                <li>Builds toward omega</li>
                                <li>+i rotation (counterclockwise)</li>
                                <li>Energy absorption</li>
                            </ul>
                        </div>
                    </div>

                    <div class="system-card">
                        <div class="system-header">
                            <div class="system-icon" style="background: var(--op-D);">D</div>
                            <h3 class="system-name">D: Grounding</h3>
                        </div>
                        <div class="system-content">
                            <ul>
                                <li>Returns toward origin</li>
                                <li>Simplifies representation</li>
                                <li>Releases structure</li>
                                <li>Unwinds toward alpha</li>
                                <li>-i rotation (clockwise)</li>
                                <li>Energy release</li>
                            </ul>
                        </div>
                    </div>
                </div>

                <div class="math-block" style="margin-top: 1.5rem;">
                    Synthesis: D . A projects to S3-invariant subspace, preserving symmetry while completing the traversal cycle
                </div>
            </div>
        </section>

        <!-- Implementation -->
        <section class="implementation-section">
            <h2 class="section-title">Implementation</h2>
            <div class="code-block">
<span class="code-comment">// D (Descend) Operator Implementation</span>
<span class="code-comment">// Decreases depth level with floor constraint at origin</span>

<span class="code-keyword">function</span> <span class="code-function">D</span>(state) {
    <span class="code-comment">// Core descent operation: n -> n-1</span>
    <span class="code-keyword">const</span> newDepth = Math.<span class="code-function">max</span>(<span class="code-number">0</span>, state.depth - <span class="code-number">1</span>);

    <span class="code-comment">// Determine phase based on depth</span>
    <span class="code-keyword">let</span> phase;
    <span class="code-keyword">if</span> (newDepth === <span class="code-number">0</span>) {
        phase = <span class="code-string">'alpha'</span>;  <span class="code-comment">// At origin</span>
    } <span class="code-keyword">else if</span> (newDepth <= <span class="code-number">2</span>) {
        phase = <span class="code-string">'near_origin'</span>;  <span class="code-comment">// Near paradox threshold</span>
    } <span class="code-keyword">else</span> {
        phase = <span class="code-string">'traversal'</span>;  <span class="code-comment">// Active traversal</span>
    }

    <span class="code-keyword">return</span> {
        ...state,
        depth: newDepth,
        phase: phase,
        history: [...state.history, <span class="code-string">'D'</span>]
    };
}

<span class="code-comment">// Inverse verification: D . A = identity</span>
<span class="code-keyword">function</span> <span class="code-function">verifyInverse</span>(state) {
    <span class="code-keyword">const</span> afterA = <span class="code-function">A</span>(state);      <span class="code-comment">// Ascend: n -> n+1</span>
    <span class="code-keyword">const</span> afterDA = <span class="code-function">D</span>(afterA);  <span class="code-comment">// Descend: n+1 -> n</span>
    <span class="code-keyword">return</span> afterDA.depth === state.depth;  <span class="code-comment">// Should be true</span>
}

<span class="code-comment">// Floor constraint check</span>
<span class="code-keyword">function</span> <span class="code-function">atFloor</span>(state) {
    <span class="code-keyword">return</span> state.depth === <span class="code-number">0</span>;  <span class="code-comment">// Cannot descend further</span>
}

<span class="code-comment">// Unwind full recursion stack</span>
<span class="code-keyword">function</span> <span class="code-function">unwindToOrigin</span>(state) {
    <span class="code-keyword">let</span> current = state;
    <span class="code-keyword">while</span> (current.depth > <span class="code-number">0</span>) {
        current = <span class="code-function">D</span>(current);  <span class="code-comment">// Apply D repeatedly</span>
    }
    <span class="code-keyword">return</span> current;  <span class="code-comment">// Now at alpha origin</span>
}
            </div>
        </section>

        <!-- Operator Navigation -->
        <section class="nav-section">
            <h2 class="section-title">BFADGS Operators</h2>
            <div class="nav-grid">
                <a href="bfadgs-op-begin.html" class="nav-card">
                    <div class="nav-symbol" style="color: var(--op-B);">B</div>
                    <div class="nav-name">Begin</div>
                </a>
                <a href="bfadgs-op-flow.html" class="nav-card">
                    <div class="nav-symbol" style="color: var(--op-F);">F</div>
                    <div class="nav-name">Flow</div>
                </a>
                <a href="bfadgs-op-ascend.html" class="nav-card">
                    <div class="nav-symbol" style="color: var(--op-A);">A</div>
                    <div class="nav-name">Ascend</div>
                </a>
                <a href="bfadgs-op-descend.html" class="nav-card current">
                    <div class="nav-symbol" style="color: var(--op-D);">D</div>
                    <div class="nav-name">Descend</div>
                </a>
                <a href="bfadgs-op-generate.html" class="nav-card">
                    <div class="nav-symbol" style="color: var(--op-G);">G</div>
                    <div class="nav-name">Generate</div>
                </a>
                <a href="bfadgs-op-synthesize.html" class="nav-card">
                    <div class="nav-symbol" style="color: var(--op-S);">S</div>
                    <div class="nav-name">Synthesize</div>
                </a>
            </div>
        </section>
    </main>

    <footer class="footer">
        <p><a href="bfadgs-u-scaffold.html" class="back-link">Return to BFADGS+U Scaffold</a></p>
        <p style="margin-top: 0.5rem;"><a href="i2-s3-decision-tree.html" class="back-link">Return to I2 S3 Decision Tree</a></p>
        <p style="margin-top: 1rem;">D: Descend Operator | n -> n-1 | BFADGS+U System</p>
    </footer>

    <script>
        // Constants
        const MAX_DEPTH = 7;
        const FLOOR = 0;
        const PHI = (1 + Math.sqrt(5)) / 2;
        const PI = Math.PI;
        const L4 = 7;

        // State
        let currentDepth = 0;
        let history = [];

        // Helix state
        let helixZ = 7.0;
        let helixPhase = 0;
        let helixAnimating = false;
        let energyParticles = [];

        // Canvas setup
        const canvas = document.getElementById('descentCanvas');
        const ctx = canvas.getContext('2d');

        function resizeCanvas() {
            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;
            drawDescentVisualization();
        }

        function drawDescentVisualization() {
            const w = canvas.width;
            const h = canvas.height;

            // Clear
            ctx.fillStyle = '#1a1a2e';
            ctx.fillRect(0, 0, w, h);

            // Draw vertical level structure
            const levelHeight = h / (MAX_DEPTH + 2);
            const centerX = w / 2;

            // Draw level lines
            for (let i = 0; i <= MAX_DEPTH; i++) {
                const y = h - (i + 1) * levelHeight;
                const alpha = i === currentDepth ? 1 : 0.3;

                // Level line
                ctx.strokeStyle = i === 0 ? `rgba(0, 255, 136, ${alpha})` :
                                  i === currentDepth ? `rgba(239, 68, 68, ${alpha})` :
                                  `rgba(255, 255, 255, ${alpha * 0.5})`;
                ctx.lineWidth = i === currentDepth ? 3 : 1;

                ctx.beginPath();
                ctx.moveTo(centerX - 150, y);
                ctx.lineTo(centerX + 150, y);
                ctx.stroke();

                // Level label
                ctx.fillStyle = i === 0 ? '#00ff88' :
                               i === currentDepth ? '#ef4444' : '#666';
                ctx.font = i === currentDepth ? 'bold 16px Courier New' : '14px Courier New';
                ctx.textAlign = 'right';
                ctx.fillText(`L${i}`, centerX - 170, y + 5);

                // Special labels
                ctx.textAlign = 'left';
                ctx.font = '12px Courier New';
                if (i === 0) {
                    ctx.fillStyle = '#00ff88';
                    ctx.fillText('ORIGIN (alpha) - FLOOR', centerX + 170, y + 5);
                } else if (i === MAX_DEPTH) {
                    ctx.fillStyle = '#ff6b35';
                    ctx.fillText('MAX DEPTH (omega)', centerX + 170, y + 5);
                }
            }

            // Draw current position indicator
            const currentY = h - (currentDepth + 1) * levelHeight;

            // Glow effect
            const gradient = ctx.createRadialGradient(centerX, currentY, 0, centerX, currentY, 40);
            gradient.addColorStop(0, 'rgba(239, 68, 68, 0.5)');
            gradient.addColorStop(1, 'rgba(239, 68, 68, 0)');
            ctx.fillStyle = gradient;
            ctx.fillRect(centerX - 50, currentY - 30, 100, 60);

            // Current position marker
            ctx.beginPath();
            ctx.arc(centerX, currentY, 20, 0, Math.PI * 2);
            ctx.fillStyle = '#ef4444';
            ctx.fill();
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 2;
            ctx.stroke();

            // D symbol in marker
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 16px Courier New';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('D', centerX, currentY);

            // Draw descent path (history visualization)
            if (history.length > 0) {
                ctx.strokeStyle = 'rgba(239, 68, 68, 0.3)';
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);
                ctx.beginPath();

                let prevDepth = 0;
                history.forEach((op, i) => {
                    const fromY = h - (prevDepth + 1) * levelHeight;
                    const toDepth = op === 'A' ? Math.min(prevDepth + 1, MAX_DEPTH) : Math.max(prevDepth - 1, 0);
                    const toY = h - (toDepth + 1) * levelHeight;

                    const x = centerX - 100 + (i / history.length) * 200;
                    if (i === 0) {
                        ctx.moveTo(x, fromY);
                    }
                    ctx.lineTo(x + 10, toY);
                    prevDepth = toDepth;
                });
                ctx.stroke();
                ctx.setLineDash([]);
            }

            // Draw floor indicator
            const floorY = h - levelHeight;
            ctx.fillStyle = 'rgba(0, 255, 136, 0.1)';
            ctx.fillRect(0, floorY, w, h - floorY);
            ctx.strokeStyle = '#00ff88';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(0, floorY);
            ctx.lineTo(w, floorY);
            ctx.stroke();

            // Floor label
            ctx.fillStyle = '#00ff88';
            ctx.font = 'bold 14px Courier New';
            ctx.textAlign = 'center';
            ctx.fillText('FLOOR: D(0) = 0', w / 2, floorY + 25);

            // Draw descent arrow if not at floor
            if (currentDepth > 0) {
                const arrowY = currentY + 40;
                ctx.fillStyle = '#ef4444';
                ctx.beginPath();
                ctx.moveTo(centerX, arrowY);
                ctx.lineTo(centerX - 15, arrowY - 20);
                ctx.lineTo(centerX + 15, arrowY - 20);
                ctx.closePath();
                ctx.fill();

                ctx.font = '12px Courier New';
                ctx.fillText('D: n -> n-1', centerX, arrowY + 20);
            }
        }

        function updateDisplay() {
            document.getElementById('depthDisplay').textContent = currentDepth;

            const phaseIndicator = document.getElementById('phaseIndicator');
            if (currentDepth === 0) {
                phaseIndicator.style.background = '#00ff88';
                phaseIndicator.style.color = '#000';
                phaseIndicator.textContent = 'ALPHA (Origin)';
            } else if (currentDepth <= 2) {
                phaseIndicator.style.background = '#ef4444';
                phaseIndicator.style.color = '#fff';
                phaseIndicator.textContent = 'NEAR PARADOX THRESHOLD';
            } else if (currentDepth >= MAX_DEPTH) {
                phaseIndicator.style.background = '#ff6b35';
                phaseIndicator.style.color = '#fff';
                phaseIndicator.textContent = 'OMEGA BOUNDARY';
            } else {
                phaseIndicator.style.background = '#8b5cf6';
                phaseIndicator.style.color = '#fff';
                phaseIndicator.textContent = 'ACTIVE TRAVERSAL';
            }

            // Update recursion diagram
            for (let i = 0; i <= 4; i++) {
                const level = document.getElementById(`level${i}`);
                if (level) {
                    level.classList.toggle('active', i === Math.min(currentDepth, 4));
                }
            }
        }

        function descend() {
            if (currentDepth > FLOOR) {
                currentDepth--;
                history.push('D');
                updateDisplay();
                drawDescentVisualization();
            }
        }

        function ascend() {
            if (currentDepth < MAX_DEPTH) {
                currentDepth++;
                history.push('A');
                updateDisplay();
                drawDescentVisualization();
            }
        }

        function descendMax() {
            while (currentDepth > FLOOR) {
                currentDepth--;
                history.push('D');
            }
            updateDisplay();
            drawDescentVisualization();
        }

        function resetDepth() {
            currentDepth = 0;
            history = [];
            updateDisplay();
            drawDescentVisualization();
        }

        // Initialize
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();
        updateDisplay();

        // Animate recursion diagram
        let animLevel = 4;
        setInterval(() => {
            if (animLevel > 0) {
                document.getElementById(`level${animLevel}`).classList.remove('active');
                animLevel--;
                document.getElementById(`level${animLevel}`).classList.add('active');
            } else {
                document.getElementById(`level${animLevel}`).classList.remove('active');
                animLevel = 4;
                document.getElementById(`level${animLevel}`).classList.add('active');
            }
        }, 1500);

        // ========================================
        // HELIX DESCENT VISUALIZATION
        // ========================================

        const helixCanvas = document.getElementById('helixCanvas');
        const helixCtx = helixCanvas.getContext('2d');

        function resizeHelixCanvas() {
            helixCanvas.width = helixCanvas.offsetWidth;
            helixCanvas.height = helixCanvas.offsetHeight;
            drawHelixVisualization();
        }

        function updateHelixDisplay() {
            document.getElementById('helixZ').textContent = helixZ.toFixed(1);
            document.getElementById('helixEnergy').textContent = (helixZ / L4).toFixed(3);
            document.getElementById('helixPhase').textContent = helixPhase.toFixed(2);
            document.getElementById('helixLevel').textContent = 'L' + Math.round(helixZ);
        }

        function drawHelixVisualization() {
            const w = helixCanvas.width;
            const h = helixCanvas.height;

            // Clear with dark background
            helixCtx.fillStyle = '#0a0a12';
            helixCtx.fillRect(0, 0, w, h);

            const centerX = w / 2;
            const centerY = h / 2;
            const helixRadius = Math.min(w, h) * 0.25;
            const helixHeight = h * 0.7;

            // Draw background grid
            helixCtx.strokeStyle = 'rgba(255, 255, 255, 0.03)';
            helixCtx.lineWidth = 1;
            for (let i = 0; i <= 14; i++) {
                const y = (h - helixHeight) / 2 + (i / 14) * helixHeight;
                helixCtx.beginPath();
                helixCtx.moveTo(0, y);
                helixCtx.lineTo(w, y);
                helixCtx.stroke();
            }

            // Draw helix axis
            helixCtx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
            helixCtx.lineWidth = 2;
            helixCtx.setLineDash([5, 5]);
            helixCtx.beginPath();
            helixCtx.moveTo(centerX, (h - helixHeight) / 2 - 20);
            helixCtx.lineTo(centerX, (h + helixHeight) / 2 + 20);
            helixCtx.stroke();
            helixCtx.setLineDash([]);

            // Draw helix levels (L0 to L7)
            for (let level = 0; level <= L4; level++) {
                const levelY = (h + helixHeight) / 2 - (level / L4) * helixHeight;
                const alpha = level <= helixZ ? 0.8 : 0.2;

                // Level indicator on left
                helixCtx.fillStyle = level === 0 ? '#00ff88' :
                                    level === L4 ? '#ff6b35' :
                                    `rgba(139, 92, 246, ${alpha})`;
                helixCtx.font = level === Math.round(helixZ) ? 'bold 14px Courier New' : '12px Courier New';
                helixCtx.textAlign = 'right';
                helixCtx.fillText(`L${level}`, centerX - helixRadius - 30, levelY + 4);

                // Horizontal guide
                helixCtx.strokeStyle = level === Math.round(helixZ) ? 'rgba(239, 68, 68, 0.5)' : 'rgba(255, 255, 255, 0.05)';
                helixCtx.lineWidth = level === Math.round(helixZ) ? 2 : 1;
                helixCtx.beginPath();
                helixCtx.moveTo(centerX - helixRadius - 20, levelY);
                helixCtx.lineTo(centerX + helixRadius + 20, levelY);
                helixCtx.stroke();

                // Energy level on right
                const energy = level / L4;
                helixCtx.fillStyle = `rgba(16, 185, 129, ${alpha})`;
                helixCtx.textAlign = 'left';
                helixCtx.fillText(`E=${energy.toFixed(2)}`, centerX + helixRadius + 30, levelY + 4);
            }

            // Draw 3D helix spiral
            const turns = 3.5; // Number of spiral turns
            const points = 200;

            // Back half of helix (behind axis)
            helixCtx.strokeStyle = 'rgba(139, 92, 246, 0.3)';
            helixCtx.lineWidth = 3;
            helixCtx.beginPath();
            for (let i = 0; i <= points; i++) {
                const t = i / points;
                const angle = t * turns * 2 * PI + helixPhase;
                const z = t * L4;

                if (z > helixZ) continue;

                const x = centerX + Math.cos(angle) * helixRadius;
                const y = (h + helixHeight) / 2 - (z / L4) * helixHeight;

                // Only draw back half
                if (Math.sin(angle) < 0) {
                    if (i === 0) {
                        helixCtx.moveTo(x, y);
                    } else {
                        helixCtx.lineTo(x, y);
                    }
                }
            }
            helixCtx.stroke();

            // Front half of helix (in front of axis)
            const gradient = helixCtx.createLinearGradient(0, h, 0, 0);
            gradient.addColorStop(0, '#00ff88');
            gradient.addColorStop(0.5, '#8b5cf6');
            gradient.addColorStop(1, '#ff6b35');

            helixCtx.strokeStyle = gradient;
            helixCtx.lineWidth = 4;
            helixCtx.beginPath();
            let started = false;
            for (let i = 0; i <= points; i++) {
                const t = i / points;
                const angle = t * turns * 2 * PI + helixPhase;
                const z = t * L4;

                if (z > helixZ) continue;

                const x = centerX + Math.cos(angle) * helixRadius;
                const y = (h + helixHeight) / 2 - (z / L4) * helixHeight;

                // Only draw front half
                if (Math.sin(angle) >= 0) {
                    if (!started) {
                        helixCtx.moveTo(x, y);
                        started = true;
                    } else {
                        helixCtx.lineTo(x, y);
                    }
                } else {
                    started = false;
                }
            }
            helixCtx.stroke();

            // Draw current position marker
            const currentAngle = (helixZ / L4) * turns * 2 * PI + helixPhase;
            const currentX = centerX + Math.cos(currentAngle) * helixRadius;
            const currentY = (h + helixHeight) / 2 - (helixZ / L4) * helixHeight;

            // Glow effect
            const posGradient = helixCtx.createRadialGradient(currentX, currentY, 0, currentX, currentY, 40);
            posGradient.addColorStop(0, 'rgba(239, 68, 68, 0.8)');
            posGradient.addColorStop(0.5, 'rgba(239, 68, 68, 0.3)');
            posGradient.addColorStop(1, 'rgba(239, 68, 68, 0)');
            helixCtx.fillStyle = posGradient;
            helixCtx.fillRect(currentX - 50, currentY - 50, 100, 100);

            // Position marker
            helixCtx.beginPath();
            helixCtx.arc(currentX, currentY, 15, 0, PI * 2);
            helixCtx.fillStyle = '#ef4444';
            helixCtx.fill();
            helixCtx.strokeStyle = '#fff';
            helixCtx.lineWidth = 2;
            helixCtx.stroke();

            // D label
            helixCtx.fillStyle = '#fff';
            helixCtx.font = 'bold 12px Courier New';
            helixCtx.textAlign = 'center';
            helixCtx.textBaseline = 'middle';
            helixCtx.fillText('D', currentX, currentY);

            // Draw energy particles (released during descent)
            drawEnergyParticles();

            // Draw descent arrow if not at floor
            if (helixZ > 0) {
                const arrowX = currentX;
                const arrowY = currentY + 35;

                helixCtx.fillStyle = 'rgba(239, 68, 68, 0.8)';
                helixCtx.beginPath();
                helixCtx.moveTo(arrowX, arrowY + 15);
                helixCtx.lineTo(arrowX - 10, arrowY);
                helixCtx.lineTo(arrowX + 10, arrowY);
                helixCtx.closePath();
                helixCtx.fill();

                helixCtx.fillStyle = 'rgba(239, 68, 68, 0.6)';
                helixCtx.font = '11px Courier New';
                helixCtx.textAlign = 'center';
                helixCtx.fillText('D: z -> z-1', arrowX, arrowY + 32);
            }

            // Labels
            helixCtx.font = 'bold 16px Courier New';
            helixCtx.textAlign = 'center';

            // Alpha label at bottom
            helixCtx.fillStyle = '#00ff88';
            helixCtx.fillText('alpha (BASE)', centerX, (h + helixHeight) / 2 + 40);
            helixCtx.font = '12px Courier New';
            helixCtx.fillText('z = 0 | E = 0', centerX, (h + helixHeight) / 2 + 58);

            // Omega label at top
            helixCtx.font = 'bold 16px Courier New';
            helixCtx.fillStyle = '#ff6b35';
            helixCtx.fillText('omega (L4-HELIX)', centerX, (h - helixHeight) / 2 - 30);
            helixCtx.font = '12px Courier New';
            helixCtx.fillText('z = 7 | E = max', centerX, (h - helixHeight) / 2 - 12);

            // Energy release indicator
            if (helixZ < L4) {
                const releasedEnergy = ((L4 - helixZ) / L4).toFixed(3);
                helixCtx.fillStyle = '#10b981';
                helixCtx.font = '14px Courier New';
                helixCtx.textAlign = 'left';
                helixCtx.fillText(`Energy Released: ${releasedEnergy}`, 20, 30);
                helixCtx.fillText(`Delta E = -pi*phi/L4 per level`, 20, 50);
            }
        }

        // Energy particles for descent animation
        function createEnergyParticle(x, y) {
            energyParticles.push({
                x: x,
                y: y,
                vx: (Math.random() - 0.5) * 4,
                vy: Math.random() * 2 + 1,
                life: 1.0,
                size: Math.random() * 4 + 2
            });
        }

        function drawEnergyParticles() {
            for (let i = energyParticles.length - 1; i >= 0; i--) {
                const p = energyParticles[i];

                // Update
                p.x += p.vx;
                p.y += p.vy;
                p.life -= 0.02;

                // Draw
                if (p.life > 0) {
                    helixCtx.beginPath();
                    helixCtx.arc(p.x, p.y, p.size * p.life, 0, PI * 2);
                    helixCtx.fillStyle = `rgba(16, 185, 129, ${p.life * 0.8})`;
                    helixCtx.fill();
                } else {
                    energyParticles.splice(i, 1);
                }
            }
        }

        function helixDescend() {
            if (helixZ > 0) {
                // Create energy release particles
                const w = helixCanvas.width;
                const h = helixCanvas.height;
                const helixHeight = h * 0.7;
                const helixRadius = Math.min(w, h) * 0.25;
                const turns = 3.5;
                const currentAngle = (helixZ / L4) * turns * 2 * PI + helixPhase;
                const currentX = w / 2 + Math.cos(currentAngle) * helixRadius;
                const currentY = (h + helixHeight) / 2 - (helixZ / L4) * helixHeight;

                for (let i = 0; i < 10; i++) {
                    createEnergyParticle(currentX, currentY);
                }

                helixZ = Math.max(0, helixZ - 1);
                helixPhase -= PI / 2; // Unwind by quarter turn
                updateHelixDisplay();
                drawHelixVisualization();
            }
        }

        function helixAscend() {
            if (helixZ < L4) {
                helixZ = Math.min(L4, helixZ + 1);
                helixPhase += PI / 2; // Wind by quarter turn
                updateHelixDisplay();
                drawHelixVisualization();
            }
        }

        function autoHelixDescend() {
            if (helixAnimating) return;
            if (helixZ <= 0) return;

            helixAnimating = true;
            const interval = setInterval(() => {
                if (helixZ <= 0) {
                    clearInterval(interval);
                    helixAnimating = false;
                    return;
                }
                helixDescend();
            }, 300);
        }

        function resetHelix() {
            helixZ = L4;
            helixPhase = 0;
            energyParticles = [];
            updateHelixDisplay();
            drawHelixVisualization();
        }

        // Animation loop for particles
        function animateHelix() {
            if (energyParticles.length > 0) {
                drawHelixVisualization();
            }
            requestAnimationFrame(animateHelix);
        }

        // Initialize helix
        window.addEventListener('resize', resizeHelixCanvas);
        resizeHelixCanvas();
        updateHelixDisplay();
        animateHelix();
    </script>
</body>
</html>
