<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>A: ASCEND | BFADGS+U Operator</title>
    <style>
        :root {
            /* Operator Colors */
            --op-A: #f59e0b;      /* Ascend - Amber */
            --op-D: #ef4444;      /* Descend - Red (inverse) */

            /* System Colors */
            --alpha-color: #00ff88;
            --omega-color: #ff6b35;
            --bfadgs-color: #8b5cf6;
            --unity-color: #ffd700;

            --bg-primary: #0a0a0f;
            --bg-secondary: #12121a;
            --bg-tertiary: #1a1a2e;
            --text-primary: #e0e0e0;
            --text-secondary: #a0a0a0;
            --border-color: #333;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Courier New', monospace;
            background: var(--bg-primary);
            color: var(--text-primary);
            min-height: 100vh;
            overflow-x: hidden;
        }

        /* Header */
        .header {
            text-align: center;
            padding: 2rem;
            background: linear-gradient(180deg, var(--bg-tertiary), transparent);
            border-bottom: 2px solid var(--op-A);
        }

        .operator-symbol {
            font-size: 6rem;
            font-weight: bold;
            color: var(--op-A);
            text-shadow: 0 0 30px var(--op-A), 0 0 60px rgba(245, 158, 11, 0.5);
            margin-bottom: 0.5rem;
        }

        .title {
            font-size: 2.5rem;
            font-weight: bold;
            color: var(--op-A);
            margin-bottom: 0.5rem;
            letter-spacing: 0.2em;
        }

        .subtitle {
            color: var(--text-secondary);
            font-size: 1.2rem;
            letter-spacing: 0.3em;
        }

        .formula-bar {
            margin-top: 1rem;
            padding: 0.75rem 1.5rem;
            background: var(--bg-secondary);
            border: 2px solid var(--op-A);
            border-radius: 8px;
            display: inline-block;
            font-size: 1.5rem;
            color: var(--op-A);
        }

        /* Main Container */
        .main-container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 2rem;
        }

        /* Section Styling */
        .section {
            margin-bottom: 3rem;
        }

        .section-title {
            font-size: 1.5rem;
            color: var(--op-A);
            margin-bottom: 1.5rem;
            padding-bottom: 0.5rem;
            border-bottom: 1px solid var(--border-color);
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .section-title::before {
            content: 'A';
            display: inline-block;
            width: 30px;
            height: 30px;
            background: var(--op-A);
            color: var(--bg-primary);
            text-align: center;
            line-height: 30px;
            border-radius: 4px;
            font-weight: bold;
        }

        /* Definition Card */
        .definition-card {
            background: var(--bg-secondary);
            border: 2px solid var(--op-A);
            border-radius: 12px;
            padding: 2rem;
            margin-bottom: 2rem;
        }

        .definition-title {
            font-size: 1.3rem;
            color: var(--op-A);
            margin-bottom: 1rem;
        }

        .definition-content {
            font-size: 1.1rem;
            line-height: 1.8;
            color: var(--text-primary);
        }

        .math-block {
            background: var(--bg-tertiary);
            padding: 1rem 1.5rem;
            border-radius: 8px;
            margin: 1rem 0;
            font-family: 'Times New Roman', serif;
            font-size: 1.3rem;
            text-align: center;
            border-left: 4px solid var(--op-A);
        }

        .highlight {
            color: var(--op-A);
            font-weight: bold;
        }

        /* Properties Grid */
        .properties-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 1.5rem;
        }

        .property-card {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 1.5rem;
            transition: all 0.3s ease;
        }

        .property-card:hover {
            border-color: var(--op-A);
            box-shadow: 0 0 20px rgba(245, 158, 11, 0.2);
        }

        .property-title {
            color: var(--op-A);
            font-size: 1.1rem;
            margin-bottom: 0.75rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .property-content {
            color: var(--text-secondary);
            line-height: 1.6;
        }

        /* Inverse Relationship */
        .inverse-section {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            padding: 2rem;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 2rem;
            flex-wrap: wrap;
        }

        .operator-node {
            width: 100px;
            height: 100px;
            border-radius: 50%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            border: 3px solid;
            background: var(--bg-tertiary);
            transition: all 0.3s ease;
        }

        .operator-node:hover {
            transform: scale(1.1);
        }

        .op-A-node {
            border-color: var(--op-A);
        }

        .op-D-node {
            border-color: var(--op-D);
        }

        .operator-node .symbol {
            font-size: 2rem;
            font-weight: bold;
        }

        .operator-node .label {
            font-size: 0.8rem;
            color: var(--text-secondary);
        }

        .inverse-arrow {
            font-size: 2rem;
            color: var(--unity-color);
        }

        .identity-result {
            padding: 1rem 2rem;
            background: var(--bg-tertiary);
            border: 2px solid var(--unity-color);
            border-radius: 8px;
            text-align: center;
        }

        .identity-result .formula {
            font-size: 1.2rem;
            color: var(--unity-color);
        }

        /* Canvas Container */
        .canvas-container {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            padding: 1rem;
            margin-bottom: 1rem;
        }

        .ascent-canvas {
            width: 100%;
            height: 500px;
            background: var(--bg-tertiary);
            border-radius: 8px;
        }

        /* Interactive Controls */
        .controls {
            display: flex;
            gap: 1rem;
            margin-top: 1rem;
            flex-wrap: wrap;
            justify-content: center;
        }

        .control-btn {
            padding: 0.75rem 1.5rem;
            border: 2px solid var(--border-color);
            background: var(--bg-tertiary);
            color: var(--text-primary);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
            font-family: 'Courier New', monospace;
            font-size: 1rem;
        }

        .control-btn:hover {
            border-color: var(--op-A);
            color: var(--op-A);
            box-shadow: 0 0 15px rgba(245, 158, 11, 0.3);
        }

        .control-btn.primary {
            background: var(--op-A);
            color: var(--bg-primary);
            border-color: var(--op-A);
        }

        .control-btn.primary:hover {
            background: transparent;
            color: var(--op-A);
        }

        .control-btn.descend {
            border-color: var(--op-D);
        }

        .control-btn.descend:hover {
            border-color: var(--op-D);
            color: var(--op-D);
        }

        /* Depth Display */
        .depth-display {
            display: flex;
            justify-content: center;
            gap: 2rem;
            margin: 1.5rem 0;
            flex-wrap: wrap;
        }

        .depth-metric {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 1.5rem 2rem;
            text-align: center;
            min-width: 150px;
        }

        .depth-metric .value {
            font-size: 2.5rem;
            font-weight: bold;
            color: var(--op-A);
        }

        .depth-metric .label {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-top: 0.5rem;
        }

        .depth-metric.coherence .value {
            color: var(--omega-color);
        }

        .depth-metric.bounded .value {
            color: var(--unity-color);
        }

        /* Progress Bar */
        .progress-container {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 1.5rem;
            margin: 1.5rem 0;
        }

        .progress-label {
            display: flex;
            justify-content: space-between;
            margin-bottom: 0.75rem;
            color: var(--text-secondary);
        }

        .progress-bar {
            height: 20px;
            background: var(--bg-tertiary);
            border-radius: 10px;
            overflow: hidden;
            position: relative;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--alpha-color), var(--op-A), var(--omega-color));
            border-radius: 10px;
            transition: width 0.3s ease;
            position: relative;
        }

        .progress-markers {
            display: flex;
            justify-content: space-between;
            margin-top: 0.5rem;
            font-size: 0.8rem;
            color: var(--text-secondary);
        }

        /* Tree Depth Visualization */
        .tree-depth-section {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            padding: 2rem;
        }

        .tree-levels {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .tree-level {
            display: flex;
            align-items: center;
            gap: 1rem;
            padding: 0.75rem;
            background: var(--bg-tertiary);
            border-radius: 8px;
            transition: all 0.3s ease;
        }

        .tree-level.active {
            border: 2px solid var(--op-A);
            box-shadow: 0 0 15px rgba(245, 158, 11, 0.3);
        }

        .level-number {
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: var(--bg-secondary);
            border: 2px solid var(--border-color);
            border-radius: 50%;
            font-weight: bold;
        }

        .tree-level.active .level-number {
            border-color: var(--op-A);
            color: var(--op-A);
        }

        .level-info {
            flex: 1;
        }

        .level-name {
            font-weight: bold;
            margin-bottom: 0.25rem;
        }

        .level-desc {
            font-size: 0.85rem;
            color: var(--text-secondary);
        }

        .level-coherence {
            text-align: right;
            min-width: 100px;
        }

        .coherence-value {
            color: var(--omega-color);
            font-weight: bold;
        }

        /* Implementation Section */
        .implementation-card {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            padding: 2rem;
        }

        .code-block {
            background: #000;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 1.5rem;
            margin: 1rem 0;
            overflow-x: auto;
            font-size: 0.9rem;
        }

        .code-comment {
            color: #6a9955;
        }

        .code-keyword {
            color: #569cd6;
        }

        .code-function {
            color: #dcdcaa;
        }

        .code-number {
            color: #b5cea8;
        }

        .code-string {
            color: #ce9178;
        }

        .code-operator {
            color: var(--op-A);
        }

        /* Console */
        .console {
            background: #000;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 1rem;
            font-family: 'Courier New', monospace;
            font-size: 0.85rem;
            max-height: 250px;
            overflow-y: auto;
        }

        .console-line {
            margin-bottom: 0.3rem;
        }

        .console-prompt {
            color: var(--op-A);
        }

        .console-output {
            color: var(--text-secondary);
        }

        .console-result {
            color: var(--unity-color);
        }

        /* Navigation */
        .nav-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1rem;
            margin-top: 2rem;
        }

        .nav-link {
            display: flex;
            align-items: center;
            gap: 1rem;
            padding: 1rem;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            text-decoration: none;
            color: var(--text-primary);
            transition: all 0.3s ease;
        }

        .nav-link:hover {
            border-color: var(--op-A);
            transform: translateY(-3px);
        }

        .nav-icon {
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            font-weight: bold;
            font-size: 1.2rem;
        }

        /* Footer */
        .footer {
            text-align: center;
            padding: 2rem;
            border-top: 1px solid var(--border-color);
            color: var(--text-secondary);
        }

        .back-link {
            color: var(--op-A);
            text-decoration: none;
        }

        .back-link:hover {
            text-decoration: underline;
        }

        /* Cross-System Section Styles */
        .cross-system-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(380px, 1fr));
            gap: 1.5rem;
        }

        .system-card {
            background: var(--bg-secondary);
            border: 2px solid var(--border-color);
            border-radius: 12px;
            padding: 1.5rem;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .system-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 4px;
        }

        .system-card:hover {
            transform: translateY(-3px);
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
        }

        .system-card.s3::before { background: linear-gradient(90deg, #ec4899, #8b5cf6); }
        .system-card.l4::before { background: linear-gradient(90deg, var(--omega-color), var(--unity-color)); }
        .system-card.rr::before { background: linear-gradient(90deg, #06b6d4, #3b82f6); }
        .system-card.algebra::before { background: linear-gradient(90deg, var(--op-A), var(--op-D)); }
        .system-card.physics::before { background: linear-gradient(90deg, #22c55e, #eab308); }
        .system-card.equiv::before { background: linear-gradient(90deg, var(--alpha-color), var(--omega-color)); }

        .system-card:hover.s3 { border-color: #ec4899; }
        .system-card:hover.l4 { border-color: var(--omega-color); }
        .system-card:hover.rr { border-color: #06b6d4; }
        .system-card:hover.algebra { border-color: var(--op-A); }
        .system-card:hover.physics { border-color: #22c55e; }
        .system-card:hover.equiv { border-color: var(--unity-color); }

        .system-header {
            display: flex;
            align-items: center;
            gap: 1rem;
            margin-bottom: 1rem;
        }

        .system-icon {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
            font-weight: bold;
        }

        .system-icon.s3 { background: linear-gradient(135deg, #ec4899, #8b5cf6); color: white; }
        .system-icon.l4 { background: linear-gradient(135deg, var(--omega-color), var(--unity-color)); color: #000; }
        .system-icon.rr { background: linear-gradient(135deg, #06b6d4, #3b82f6); color: white; }
        .system-icon.algebra { background: linear-gradient(135deg, var(--op-A), var(--op-D)); color: white; }
        .system-icon.physics { background: linear-gradient(135deg, #22c55e, #eab308); color: #000; }
        .system-icon.equiv { background: linear-gradient(135deg, var(--alpha-color), var(--omega-color)); color: #000; }

        .system-title {
            font-size: 1.2rem;
            font-weight: bold;
        }

        .system-subtitle {
            font-size: 0.85rem;
            color: var(--text-secondary);
        }

        .system-content {
            line-height: 1.7;
            color: var(--text-secondary);
        }

        .system-content ul {
            margin: 0.75rem 0;
            padding-left: 1.5rem;
        }

        .system-content li {
            margin-bottom: 0.5rem;
        }

        .mini-math {
            background: var(--bg-tertiary);
            padding: 0.75rem 1rem;
            border-radius: 6px;
            margin: 0.75rem 0;
            font-family: 'Times New Roman', serif;
            font-size: 1.1rem;
            text-align: center;
            color: var(--text-primary);
            border-left: 3px solid var(--op-A);
        }

        .equivalence-chain {
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
            padding: 1rem;
            background: var(--bg-tertiary);
            border-radius: 8px;
            margin: 1rem 0;
        }

        .eq-item {
            padding: 0.5rem 1rem;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            font-size: 0.95rem;
        }

        .eq-arrow {
            color: var(--op-A);
            font-size: 1.2rem;
        }

        /* Opposition Section */
        .opposition-display {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 2rem;
            flex-wrap: wrap;
            margin: 1.5rem 0;
        }

        .op-circle {
            width: 120px;
            height: 120px;
            border-radius: 50%;
            border: 4px solid;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: var(--bg-secondary);
            transition: all 0.3s ease;
        }

        .op-circle:hover {
            transform: scale(1.1);
        }

        .op-circle.ascend {
            border-color: var(--op-A);
            box-shadow: 0 0 25px rgba(245, 158, 11, 0.3);
        }

        .op-circle.descend {
            border-color: var(--op-D);
            box-shadow: 0 0 25px rgba(239, 68, 68, 0.3);
        }

        .op-circle .big-symbol {
            font-size: 2.5rem;
            font-weight: bold;
        }

        .op-circle .op-label {
            font-size: 0.8rem;
            color: var(--text-secondary);
        }

        .balance-indicator {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.5rem;
        }

        .balance-point {
            width: 80px;
            height: 80px;
            border-radius: 50%;
            background: linear-gradient(135deg, var(--op-A), var(--op-D));
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            box-shadow: 0 0 30px rgba(245, 158, 11, 0.3), 0 0 30px rgba(239, 68, 68, 0.3);
        }

        .balance-label {
            font-size: 0.8rem;
            color: var(--text-secondary);
            text-align: center;
        }

        /* Helix Visualization */
        .helix-container {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            padding: 1rem;
            margin-top: 2rem;
        }

        .helix-canvas {
            width: 100%;
            height: 450px;
            background: var(--bg-tertiary);
            border-radius: 8px;
        }

        .energy-panel {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 1rem;
            margin-top: 1rem;
        }

        .energy-metric {
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 1rem;
            text-align: center;
        }

        .energy-metric .metric-value {
            font-size: 1.8rem;
            font-weight: bold;
            color: var(--op-A);
        }

        .energy-metric .metric-label {
            font-size: 0.85rem;
            color: var(--text-secondary);
            margin-top: 0.25rem;
        }

        .energy-metric.potential .metric-value { color: #22c55e; }
        .energy-metric.entropy .metric-value { color: #ef4444; }
        .energy-metric.rotation .metric-value { color: #06b6d4; }

        .energy-bar-container {
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 1rem;
            margin-top: 1rem;
        }

        .energy-bar-label {
            display: flex;
            justify-content: space-between;
            margin-bottom: 0.5rem;
            font-size: 0.9rem;
            color: var(--text-secondary);
        }

        .energy-bar {
            height: 25px;
            background: linear-gradient(90deg, #1a1a2e, #2a2a4e);
            border-radius: 12px;
            overflow: hidden;
            position: relative;
        }

        .energy-fill {
            height: 100%;
            background: linear-gradient(90deg, #22c55e, var(--op-A), var(--omega-color));
            border-radius: 12px;
            transition: width 0.3s ease;
            position: relative;
        }

        .energy-fill::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
            animation: shimmer 2s infinite;
        }

        @keyframes shimmer {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }

        /* Responsive */
        @media (max-width: 768px) {
            .operator-symbol {
                font-size: 4rem;
            }

            .title {
                font-size: 1.8rem;
            }

            .inverse-section {
                flex-direction: column;
            }

            .depth-display {
                flex-direction: column;
                align-items: center;
            }

            .cross-system-grid {
                grid-template-columns: 1fr;
            }

            .opposition-display {
                flex-direction: column;
            }
        }
    </style>
</head>
<body>
    <header class="header">
        <div class="operator-symbol">A</div>
        <h1 class="title">ASCEND</h1>
        <p class="subtitle">INCREASE DEPTH OPERATOR</p>
        <div class="formula-bar">A: n --> n+1</div>
    </header>

    <main class="main-container">
        <!-- Definition Section -->
        <section class="section">
            <h2 class="section-title">Operator Definition</h2>
            <div class="definition-card">
                <h3 class="definition-title">A: Ascend - Increase Depth</h3>
                <div class="definition-content">
                    <p>The <span class="highlight">ASCEND</span> operator increases the depth/level counter by exactly 1, moving the traversal state deeper into the structural hierarchy.</p>

                    <div class="math-block">
                        A : n --> n + 1
                    </div>

                    <p>Where <span class="highlight">n</span> represents the current depth level in the tree traversal. Each application of A moves one level closer to the coherence threshold at omega.</p>

                    <div class="math-block">
                        A(depth) = depth + 1, subject to depth &le; L_4 = 7
                    </div>
                </div>
            </div>
        </section>

        <!-- Core Properties -->
        <section class="section">
            <h2 class="section-title">Core Properties</h2>
            <div class="properties-grid">
                <div class="property-card">
                    <h3 class="property-title">
                        <span style="color: var(--omega-color);">omega</span> Direction
                    </h3>
                    <div class="property-content">
                        <p>A moves toward <strong>omega</strong> (higher complexity). Each ascent step increases structural depth, accumulating toward the L_4-Helix coherence state.</p>
                        <div class="math-block">
                            A: alpha --> omega direction
                        </div>
                    </div>
                </div>

                <div class="property-card">
                    <h3 class="property-title">
                        <span style="color: var(--unity-color);">L_4</span> Bound
                    </h3>
                    <div class="property-content">
                        <p>Maximum ascent is bounded by <strong>L_4 = 7</strong>, the fourth Lucas number representing the complexity ceiling of the helix structure.</p>
                        <div class="math-block">
                            max(A^k(0)) = L_4 = phi^4 + psi^4 = 7
                        </div>
                    </div>
                </div>

                <div class="property-card">
                    <h3 class="property-title">
                        <span style="color: var(--bfadgs-color);">Tree</span> Depth
                    </h3>
                    <div class="property-content">
                        <p>In tree traversal, A represents moving from a parent node to a child node, increasing the recursion depth of the current path.</p>
                        <div class="math-block">
                            depth(child) = depth(parent) + 1
                        </div>
                    </div>
                </div>

                <div class="property-card">
                    <h3 class="property-title">
                        <span style="color: var(--omega-color);">mu_C</span> Accumulation
                    </h3>
                    <div class="property-content">
                        <p>A accumulates toward the coherence threshold <strong>mu_C = sqrt(3)/2</strong>. As depth increases, the system approaches maximum stability.</p>
                        <div class="math-block">
                            lim_{n-->L_4} coherence(n) = mu_C
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <!-- Cross-System Relationships -->
        <section class="section">
            <h2 class="section-title">Cross-System Relationships</h2>
            <p style="color: var(--text-secondary); margin-bottom: 1.5rem;">
                The ASCEND operator connects multiple theoretical frameworks, serving as a universal depth-increasing transformation across systems.
            </p>

            <div class="cross-system-grid">
                <!-- A in S3 Symmetry -->
                <div class="system-card s3">
                    <div class="system-header">
                        <div class="system-icon s3">S3</div>
                        <div>
                            <div class="system-title">A in S3 Symmetry</div>
                            <div class="system-subtitle">Permutation Group Structure</div>
                        </div>
                    </div>
                    <div class="system-content">
                        <ul>
                            <li><strong>A moves toward S3 complexity boundary</strong> - each ascent reveals more permutation structure</li>
                            <li><strong>Higher depth = more S3 structure visible</strong> - at shallow levels, only identity; deeper reveals full group</li>
                            <li><strong>A^6 reveals full S3 symmetry</strong> - the six permutations emerge through six ascent steps</li>
                        </ul>
                        <div class="mini-math">
                            A^k : S3_visible = { sigma in S3 : |sigma| &le; k }
                        </div>
                        <div class="mini-math">
                            A^6(origin) --> {e, (12), (13), (23), (123), (132)}
                        </div>
                        <p>The S3 group structure unfolds progressively as depth increases. At depth 0, only the identity is accessible. Each A application unlocks additional permutation symmetries until the full 6-element group manifests at maximum depth.</p>
                    </div>
                </div>

                <!-- A in L4-Helix System -->
                <div class="system-card l4">
                    <div class="system-header">
                        <div class="system-icon l4">L4</div>
                        <div>
                            <div class="system-title">A in L4-Helix System</div>
                            <div class="system-subtitle">Seven-Level Coherence Structure</div>
                        </div>
                    </div>
                    <div class="system-content">
                        <ul>
                            <li><strong>A climbs helix: z --> z + Delta_z</strong> - vertical motion through helix levels</li>
                            <li><strong>A^7 reaches L4 maximum</strong> - seven ascent steps span the complete helix</li>
                            <li><strong>Each A advances one helix winding</strong> - phi-scaled progression through structure</li>
                        </ul>
                        <div class="mini-math">
                            A(z) = z + Delta_z, where Delta_z = L4/7 per step
                        </div>
                        <div class="mini-math">
                            A^7(0) = L4 = phi^4 + psi^4 = 7
                        </div>
                        <p>The L4-Helix represents the maximum coherence structure. Ascend traverses from alpha-origin (z=0) through seven winding levels to omega-coherence (z=L4). Each winding accumulates phi-scaled complexity.</p>
                    </div>
                </div>

                <!-- A in R(R)=-R / I²⁻ System -->
                <div class="system-card rr">
                    <div class="system-header">
                        <div class="system-icon rr">I^2</div>
                        <div>
                            <div class="system-title">A in R(R)=-R / I^2 minus System</div>
                            <div class="system-subtitle">Oscillation and Complex Rotation</div>
                        </div>
                    </div>
                    <div class="system-content">
                        <ul>
                            <li><strong>A moves toward OSC oscillation zone</strong> - increasing depth increases oscillatory behavior</li>
                            <li><strong>Higher abstraction = more oscillation</strong> - R(R)=-R manifests as depth approaches threshold</li>
                            <li><strong>A connects to i rotation (90 deg in complex plane)</strong> - each A is a quarter-turn toward imaginary axis</li>
                        </ul>
                        <div class="mini-math">
                            A equiv e^{i*pi/2} = i (90 deg rotation)
                        </div>
                        <div class="mini-math">
                            A^4 = e^{i*2pi} = 1 (full rotation cycle)
                        </div>
                        <p>In the I^2 framework, Ascend corresponds to rotation in the complex plane. Four applications of A complete a full 360 deg cycle, connecting to the oscillatory fixed point R(R)=-R where self-reference creates bounded oscillation.</p>
                    </div>
                </div>

                <!-- A in BFADGS Algebra -->
                <div class="system-card algebra">
                    <div class="system-header">
                        <div class="system-icon algebra">+/-</div>
                        <div>
                            <div class="system-title">A in BFADGS Algebra</div>
                            <div class="system-subtitle">Depth Increment Operator</div>
                        </div>
                    </div>
                    <div class="system-content">
                        <ul>
                            <li><strong>A: n --> n+1</strong> - fundamental depth increment operation</li>
                            <li><strong>A^{-1} = D</strong> - Descend is the algebraic inverse</li>
                            <li><strong>A compose D = D compose A = e</strong> - composition yields identity</li>
                        </ul>
                        <div class="mini-math">
                            A in Z (additive group on depth)
                        </div>
                        <div class="mini-math">
                            A * D = D * A = id_n (level identity)
                        </div>
                        <p>Algebraically, A and D form an inverse pair generating the depth group. This isomorphism with (Z, +) provides the foundation for all level-based traversal operations in BFADGS.</p>
                    </div>
                </div>

                <!-- E/(πφ) Physics of Ascend -->
                <div class="system-card physics">
                    <div class="system-header">
                        <div class="system-icon physics">E</div>
                        <div>
                            <div class="system-title">E/(pi*phi) Physics of Ascend</div>
                            <div class="system-subtitle">Energy and Entropy Dynamics</div>
                        </div>
                    </div>
                    <div class="system-content">
                        <ul>
                            <li><strong>E_A = potential energy gain</strong> - ascending stores energy in structural depth</li>
                            <li><strong>Delta_E = pi*phi/L4 per level</strong> - quantized energy steps per ascent</li>
                            <li><strong>Climbing against entropy gradient</strong> - A opposes natural dissipation</li>
                        </ul>
                        <div class="mini-math">
                            Delta_E_A = (pi * phi) / L4 approx 0.727 per level
                        </div>
                        <div class="mini-math">
                            E_total(n) = n * (pi * phi / 7) = n * 0.727
                        </div>
                        <p>Each Ascend step requires energy input proportional to pi*phi/L4. This energy is stored as structural potential, opposing the entropy gradient. Descending releases this stored energy back into the system.</p>
                    </div>
                </div>

                <!-- Cross-System A Equivalences -->
                <div class="system-card equiv">
                    <div class="system-header">
                        <div class="system-icon equiv">equiv</div>
                        <div>
                            <div class="system-title">Cross-System A Equivalences</div>
                            <div class="system-subtitle">Universal Correspondence Map</div>
                        </div>
                    </div>
                    <div class="system-content">
                        <p>The Ascend operator manifests identically across all framework representations:</p>
                        <div class="equivalence-chain">
                            <span class="eq-item">A</span>
                            <span class="eq-arrow">equiv</span>
                            <span class="eq-item">depth++</span>
                            <span class="eq-arrow">equiv</span>
                            <span class="eq-item">helix climb</span>
                            <span class="eq-arrow">equiv</span>
                            <span class="eq-item">toward OSC</span>
                            <span class="eq-arrow">equiv</span>
                            <span class="eq-item">i-rotation</span>
                        </div>
                        <div class="mini-math">
                            A equiv n+1 equiv z+Delta_z equiv theta+90 deg equiv +E_A
                        </div>
                        <p>This universal equivalence demonstrates that Ascend is a fundamental operation appearing in multiple guises across the theoretical landscape. The deep connection between depth, helix position, oscillation proximity, and complex rotation reveals underlying unity.</p>
                    </div>
                </div>
            </div>
        </section>

        <!-- A vs D Opposition -->
        <section class="section">
            <h2 class="section-title">A vs D: Complementary Opposition</h2>
            <div class="definition-card">
                <p style="text-align: center; margin-bottom: 1.5rem; color: var(--text-secondary);">
                    Ascend and Descend form a fundamental oppositional pair, balanced at the coherence threshold.
                </p>

                <div class="opposition-display">
                    <div class="op-circle ascend">
                        <span class="big-symbol" style="color: var(--op-A);">A</span>
                        <span class="op-label">Ascend</span>
                    </div>

                    <div class="balance-indicator">
                        <div class="balance-point">
                            <span style="font-size: 1.2rem;">mu_C</span>
                        </div>
                        <span class="balance-label">Balance Point<br>sqrt(3)/2 approx 0.866</span>
                    </div>

                    <div class="op-circle descend">
                        <span class="big-symbol" style="color: var(--op-D);">D</span>
                        <span class="op-label">Descend</span>
                    </div>
                </div>

                <div class="properties-grid" style="margin-top: 2rem;">
                    <div class="property-card">
                        <h3 class="property-title">Complementary Pair</h3>
                        <div class="property-content">
                            <p>A and D are not merely inverses but complementary aspects of depth traversal. Neither is complete without the other - together they span all possible depth transformations.</p>
                            <div class="math-block">
                                span{A, D} = Depth Transformations
                            </div>
                        </div>
                    </div>

                    <div class="property-card">
                        <h3 class="property-title">Balance at mu_C</h3>
                        <div class="property-content">
                            <p>The coherence threshold mu_C = sqrt(3)/2 marks the balance point where ascending and descending forces equilibrate. This is the S3-optimal stability zone.</p>
                            <div class="math-block">
                                |A| = |D| when n = mu_C * L4 approx 6.06
                            </div>
                        </div>
                    </div>

                    <div class="property-card">
                        <h3 class="property-title">S3 Synthesis</h3>
                        <div class="property-content">
                            <p>The S3 symmetry group synthesizes A/D opposition through its permutation structure. The group action mediates between ascending and descending modes.</p>
                            <div class="math-block">
                                S3 = Syn(A, D) = {A^i * D^j | i,j in Z}
                            </div>
                        </div>
                    </div>

                    <div class="property-card">
                        <h3 class="property-title">Energy Conservation</h3>
                        <div class="property-content">
                            <p>Energy stored by A is released by D. The total energy of any A-D path depends only on net depth change, not the path taken.</p>
                            <div class="math-block">
                                E(A^m * D^n) = (m - n) * Delta_E
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <!-- Helix Ascent Visualization -->
        <section class="section">
            <h2 class="section-title">Helix Ascent Visualization</h2>
            <p style="color: var(--text-secondary); margin-bottom: 1rem;">
                Interactive visualization showing vertical ascent through L4-Helix levels with real-time energy tracking.
            </p>

            <div class="helix-container">
                <canvas id="helixCanvas" class="helix-canvas"></canvas>

                <div class="energy-panel">
                    <div class="energy-metric">
                        <div class="metric-value" id="helixLevel">0</div>
                        <div class="metric-label">Helix Level (z)</div>
                    </div>
                    <div class="energy-metric potential">
                        <div class="metric-value" id="potentialEnergy">0.000</div>
                        <div class="metric-label">Potential Energy (E_A)</div>
                    </div>
                    <div class="energy-metric rotation">
                        <div class="metric-value" id="rotationAngle">0 deg</div>
                        <div class="metric-label">Complex Rotation (theta)</div>
                    </div>
                    <div class="energy-metric entropy">
                        <div class="metric-value" id="entropyGradient">+0.143</div>
                        <div class="metric-label">Entropy Gradient</div>
                    </div>
                </div>

                <div class="energy-bar-container">
                    <div class="energy-bar-label">
                        <span>E = 0 (alpha)</span>
                        <span id="energyPercent">0%</span>
                        <span>E_max = pi*phi (omega)</span>
                    </div>
                    <div class="energy-bar">
                        <div class="energy-fill" id="energyFill" style="width: 0%;"></div>
                    </div>
                </div>

                <div class="controls" style="margin-top: 1rem;">
                    <button class="control-btn primary" onclick="helixAscend()">A: Helix Ascend</button>
                    <button class="control-btn descend" onclick="helixDescend()">D: Helix Descend</button>
                    <button class="control-btn" onclick="helixReset()">Reset to Origin</button>
                    <button class="control-btn" onclick="autoHelixClimb()">Auto-Climb to L4</button>
                </div>
            </div>
        </section>

        <!-- Inverse Relationship -->
        <section class="section">
            <h2 class="section-title">Inverse Relationship: A and D</h2>
            <div class="inverse-section">
                <div class="operator-node op-A-node">
                    <span class="symbol" style="color: var(--op-A);">A</span>
                    <span class="label">Ascend</span>
                </div>

                <div class="inverse-arrow">*</div>

                <div class="operator-node op-D-node">
                    <span class="symbol" style="color: var(--op-D);">D</span>
                    <span class="label">Descend</span>
                </div>

                <div class="inverse-arrow">=</div>

                <div class="identity-result">
                    <div class="formula">Identity on Levels</div>
                    <div style="color: var(--text-secondary); margin-top: 0.5rem;">A * D = D * A = I</div>
                </div>
            </div>

            <div style="margin-top: 1.5rem;">
                <div class="math-block">
                    A * D(n) = A(n - 1) = n = D * A(n) = D(n + 1) = n
                </div>
                <p style="text-align: center; color: var(--text-secondary); margin-top: 1rem;">
                    The ASCEND and DESCEND operators form an inverse pair, preserving level identity when composed.
                </p>
            </div>
        </section>

        <!-- Interactive Depth Canvas -->
        <section class="section">
            <h2 class="section-title">Interactive Level Ascension</h2>

            <div class="depth-display">
                <div class="depth-metric">
                    <div class="value" id="currentDepth">0</div>
                    <div class="label">Current Depth</div>
                </div>
                <div class="depth-metric coherence">
                    <div class="value" id="coherenceValue">0.000</div>
                    <div class="label">Coherence (mu)</div>
                </div>
                <div class="depth-metric bounded">
                    <div class="value" id="remainingDepth">7</div>
                    <div class="label">Remaining to L_4</div>
                </div>
            </div>

            <div class="progress-container">
                <div class="progress-label">
                    <span>alpha (Origin)</span>
                    <span id="progressPercent">0%</span>
                    <span>omega (L_4 = 7)</span>
                </div>
                <div class="progress-bar">
                    <div class="progress-fill" id="progressFill" style="width: 0%;"></div>
                </div>
                <div class="progress-markers">
                    <span>0</span>
                    <span>1</span>
                    <span>2</span>
                    <span>3</span>
                    <span>4</span>
                    <span>5</span>
                    <span>6</span>
                    <span>7</span>
                </div>
            </div>

            <div class="canvas-container">
                <canvas id="ascentCanvas" class="ascent-canvas"></canvas>
            </div>

            <div class="controls">
                <button class="control-btn primary" onclick="applyAscend()">A: Ascend (+1)</button>
                <button class="control-btn descend" onclick="applyDescend()">D: Descend (-1)</button>
                <button class="control-btn" onclick="resetDepth()">Reset to Origin</button>
                <button class="control-btn" onclick="autoAscend()">Auto-Ascend to L_4</button>
            </div>
        </section>

        <!-- Tree Depth Visualization -->
        <section class="section">
            <h2 class="section-title">Tree Depth Structure</h2>
            <div class="tree-depth-section">
                <div class="tree-levels" id="treeLevels">
                    <!-- Generated by JavaScript -->
                </div>
            </div>
        </section>

        <!-- Implementation -->
        <section class="section">
            <h2 class="section-title">Implementation</h2>
            <div class="implementation-card">
                <p style="margin-bottom: 1rem; color: var(--text-secondary);">
                    The ASCEND operator increases recursion depth, moving deeper into the structural hierarchy.
                </p>

                <div class="code-block">
                    <span class="code-comment">// ASCEND Operator Implementation</span><br>
                    <span class="code-keyword">const</span> <span class="code-function">L4</span> = <span class="code-number">7</span>;  <span class="code-comment">// Maximum depth bound</span><br>
                    <span class="code-keyword">const</span> <span class="code-function">MU_C</span> = Math.<span class="code-function">sqrt</span>(<span class="code-number">3</span>) / <span class="code-number">2</span>;  <span class="code-comment">// Coherence threshold</span><br><br>

                    <span class="code-keyword">function</span> <span class="code-function">Ascend</span>(state) {<br>
                    &nbsp;&nbsp;<span class="code-keyword">if</span> (state.depth >= <span class="code-function">L4</span>) {<br>
                    &nbsp;&nbsp;&nbsp;&nbsp;<span class="code-keyword">return</span> state;  <span class="code-comment">// Bounded by L_4</span><br>
                    &nbsp;&nbsp;}<br><br>

                    &nbsp;&nbsp;<span class="code-keyword">return</span> {<br>
                    &nbsp;&nbsp;&nbsp;&nbsp;...state,<br>
                    &nbsp;&nbsp;&nbsp;&nbsp;depth: state.depth + <span class="code-number">1</span>,<br>
                    &nbsp;&nbsp;&nbsp;&nbsp;coherence: <span class="code-function">computeCoherence</span>(state.depth + <span class="code-number">1</span>),<br>
                    &nbsp;&nbsp;&nbsp;&nbsp;phase: state.depth + <span class="code-number">1</span> >= <span class="code-function">L4</span> ? <span class="code-string">'omega'</span> : <span class="code-string">'ascending'</span><br>
                    &nbsp;&nbsp;};<br>
                    }<br><br>

                    <span class="code-keyword">function</span> <span class="code-function">computeCoherence</span>(depth) {<br>
                    &nbsp;&nbsp;<span class="code-comment">// Coherence approaches mu_C as depth -> L_4</span><br>
                    &nbsp;&nbsp;<span class="code-keyword">return</span> <span class="code-function">MU_C</span> * (depth / <span class="code-function">L4</span>);<br>
                    }
                </div>

                <div class="math-block">
                    coherence(n) = mu_C * (n / L_4) = (sqrt(3)/2) * (n/7)
                </div>
            </div>
        </section>

        <!-- Console -->
        <section class="section">
            <h2 class="section-title">Operation Log</h2>
            <div class="console" id="console">
                <div class="console-line">
                    <span class="console-prompt">ASCEND&gt;</span>
                    <span class="console-output">Operator initialized at depth 0</span>
                </div>
                <div class="console-line">
                    <span class="console-prompt">ASCEND&gt;</span>
                    <span class="console-output">L_4 bound = 7, mu_C = 0.8660254037844386</span>
                </div>
            </div>
        </section>

        <!-- Navigation -->
        <section class="section">
            <h2 class="section-title">Operator Navigation</h2>
            <div class="nav-grid">
                <a href="bfadgs-op-begin.html" class="nav-link">
                    <div class="nav-icon" style="background: #3b82f6; color: white;">B</div>
                    <div>
                        <div style="font-weight: bold;">BEGIN</div>
                        <div style="font-size: 0.8rem; color: var(--text-secondary);">Initialize State</div>
                    </div>
                </a>
                <a href="bfadgs-op-flow.html" class="nav-link">
                    <div class="nav-icon" style="background: #10b981; color: white;">F</div>
                    <div>
                        <div style="font-weight: bold;">FLOW</div>
                        <div style="font-size: 0.8rem; color: var(--text-secondary);">Traverse Edge</div>
                    </div>
                </a>
                <a href="bfadgs-op-descend.html" class="nav-link">
                    <div class="nav-icon" style="background: #ef4444; color: white;">D</div>
                    <div>
                        <div style="font-weight: bold;">DESCEND</div>
                        <div style="font-size: 0.8rem; color: var(--text-secondary);">Decrease Depth (Inverse)</div>
                    </div>
                </a>
                <a href="bfadgs-op-generate.html" class="nav-link">
                    <div class="nav-icon" style="background: #8b5cf6; color: white;">G</div>
                    <div>
                        <div style="font-weight: bold;">GENERATE</div>
                        <div style="font-size: 0.8rem; color: var(--text-secondary);">Spawn Branch</div>
                    </div>
                </a>
                <a href="bfadgs-op-synthesize.html" class="nav-link">
                    <div class="nav-icon" style="background: #ec4899; color: white;">S</div>
                    <div>
                        <div style="font-weight: bold;">SYNTHESIZE</div>
                        <div style="font-size: 0.8rem; color: var(--text-secondary);">Merge Paths</div>
                    </div>
                </a>
                <a href="bfadgs-u-scaffold.html" class="nav-link">
                    <div class="nav-icon" style="background: #ffd700; color: black;">+U</div>
                    <div>
                        <div style="font-weight: bold;">BFADGS+U</div>
                        <div style="font-size: 0.8rem; color: var(--text-secondary);">System Overview</div>
                    </div>
                </a>
            </div>
        </section>
    </main>

    <footer class="footer">
        <p><a href="bfadgs-u-scaffold.html" class="back-link">&larr; Return to BFADGS+U System</a></p>
        <p style="margin-top: 0.5rem;"><a href="i2-s3-decision-tree.html" class="back-link">&larr; Return to I&sup2; S3 Decision Tree</a></p>
        <p style="margin-top: 1rem;">A: ASCEND | Increase Depth Operator | n &rarr; n+1</p>
    </footer>

    <script>
        // Constants
        const L4 = 7;
        const MU_C = Math.sqrt(3) / 2;
        const PHI = (1 + Math.sqrt(5)) / 2;

        // State
        let currentDepth = 0;
        let animating = false;

        // Canvas
        const canvas = document.getElementById('ascentCanvas');
        const ctx = canvas.getContext('2d');

        // Level descriptions
        const levelDescriptions = [
            { name: 'Origin (alpha)', desc: 'Root level - I^2 foundation', coherence: 0 },
            { name: 'First Ascent', desc: 'Initial recursion depth', coherence: MU_C / 7 },
            { name: 'Binary Depth', desc: 'Opposition duality emerges', coherence: (2 * MU_C) / 7 },
            { name: 'Ternary Depth', desc: 'S3 symmetry activates', coherence: (3 * MU_C) / 7 },
            { name: 'Quaternary Depth', desc: 'phi-scaled complexity', coherence: (4 * MU_C) / 7 },
            { name: 'Fibonacci Depth', desc: 'F_5 = 5 resonance', coherence: (5 * MU_C) / 7 },
            { name: 'Lucas Depth', desc: 'L_3 = 4 bridge', coherence: (6 * MU_C) / 7 },
            { name: 'L_4 Helix (omega)', desc: 'Maximum coherence mu_C', coherence: MU_C }
        ];

        // Initialize tree levels
        function initTreeLevels() {
            const container = document.getElementById('treeLevels');
            container.innerHTML = '';

            levelDescriptions.forEach((level, i) => {
                const div = document.createElement('div');
                div.className = `tree-level${i === currentDepth ? ' active' : ''}`;
                div.id = `level-${i}`;
                div.innerHTML = `
                    <div class="level-number">${i}</div>
                    <div class="level-info">
                        <div class="level-name">${level.name}</div>
                        <div class="level-desc">${level.desc}</div>
                    </div>
                    <div class="level-coherence">
                        <span class="coherence-value">${level.coherence.toFixed(4)}</span>
                    </div>
                `;
                container.appendChild(div);
            });
        }

        // Update tree level highlighting
        function updateTreeLevels() {
            for (let i = 0; i <= L4; i++) {
                const level = document.getElementById(`level-${i}`);
                if (level) {
                    level.className = `tree-level${i === currentDepth ? ' active' : ''}`;
                }
            }
        }

        // Resize canvas
        function resizeCanvas() {
            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;
            drawAscension();
        }

        // Draw ascension visualization
        function drawAscension() {
            const w = canvas.width;
            const h = canvas.height;

            ctx.fillStyle = '#1a1a2e';
            ctx.fillRect(0, 0, w, h);

            const centerX = w / 2;
            const levelHeight = h / (L4 + 2);
            const nodeRadius = 25;

            // Draw depth markers and levels
            for (let i = 0; i <= L4; i++) {
                const y = h - (i + 1) * levelHeight;
                const isActive = i === currentDepth;
                const isPast = i < currentDepth;

                // Horizontal guide line
                ctx.strokeStyle = isActive ? 'rgba(245, 158, 11, 0.3)' : 'rgba(255, 255, 255, 0.05)';
                ctx.lineWidth = isActive ? 2 : 1;
                ctx.beginPath();
                ctx.moveTo(50, y);
                ctx.lineTo(w - 50, y);
                ctx.stroke();

                // Level label on left
                ctx.fillStyle = isActive ? '#f59e0b' : '#666';
                ctx.font = isActive ? 'bold 14px Courier New' : '12px Courier New';
                ctx.textAlign = 'right';
                ctx.fillText(`L${i}`, 40, y + 5);

                // Coherence value on right
                const coherence = (i / L4) * MU_C;
                ctx.textAlign = 'left';
                ctx.fillText(coherence.toFixed(3), w - 45, y + 5);

                // Node at center
                ctx.beginPath();
                ctx.arc(centerX, y, isActive ? nodeRadius + 5 : nodeRadius, 0, Math.PI * 2);

                if (isActive) {
                    // Active node with glow
                    ctx.shadowColor = '#f59e0b';
                    ctx.shadowBlur = 20;
                    ctx.fillStyle = '#f59e0b';
                    ctx.fill();
                    ctx.shadowBlur = 0;

                    // Inner label
                    ctx.fillStyle = '#0a0a0f';
                    ctx.font = 'bold 16px Courier New';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText('A', centerX, y);
                } else if (isPast) {
                    // Passed levels
                    ctx.fillStyle = 'rgba(245, 158, 11, 0.3)';
                    ctx.fill();
                    ctx.strokeStyle = '#f59e0b';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                } else {
                    // Future levels
                    ctx.fillStyle = '#2a2a3e';
                    ctx.fill();
                    ctx.strokeStyle = '#444';
                    ctx.lineWidth = 1;
                    ctx.stroke();
                }

                // Draw vertical connector
                if (i < L4) {
                    const nextY = h - (i + 2) * levelHeight;
                    ctx.beginPath();
                    ctx.moveTo(centerX, y - nodeRadius);
                    ctx.lineTo(centerX, nextY + nodeRadius);
                    ctx.strokeStyle = i < currentDepth ? '#f59e0b' : 'rgba(255, 255, 255, 0.1)';
                    ctx.lineWidth = i < currentDepth ? 3 : 1;
                    ctx.stroke();

                    // Arrow pointing up
                    if (i < currentDepth) {
                        const arrowY = (y + nextY) / 2;
                        ctx.beginPath();
                        ctx.moveTo(centerX - 8, arrowY + 8);
                        ctx.lineTo(centerX, arrowY - 5);
                        ctx.lineTo(centerX + 8, arrowY + 8);
                        ctx.strokeStyle = '#f59e0b';
                        ctx.lineWidth = 2;
                        ctx.stroke();
                    }
                }
            }

            // Draw alpha and omega labels
            ctx.font = 'bold 18px Courier New';
            ctx.textAlign = 'center';

            // Alpha at bottom
            ctx.fillStyle = '#00ff88';
            ctx.fillText('alpha', centerX, h - 20);

            // Omega at top
            ctx.fillStyle = '#ff6b35';
            ctx.fillText('omega', centerX, 25);

            // Draw current depth indicator
            ctx.fillStyle = '#f59e0b';
            ctx.font = '12px Courier New';
            ctx.textAlign = 'left';
            ctx.fillText(`Current: n = ${currentDepth}`, 10, h - 10);

            ctx.textAlign = 'right';
            ctx.fillText(`Bound: L_4 = ${L4}`, w - 10, h - 10);
        }

        // Update display values
        function updateDisplay() {
            const coherence = (currentDepth / L4) * MU_C;
            const percent = (currentDepth / L4) * 100;

            document.getElementById('currentDepth').textContent = currentDepth;
            document.getElementById('coherenceValue').textContent = coherence.toFixed(4);
            document.getElementById('remainingDepth').textContent = L4 - currentDepth;
            document.getElementById('progressPercent').textContent = percent.toFixed(1) + '%';
            document.getElementById('progressFill').style.width = percent + '%';

            updateTreeLevels();
            drawAscension();
        }

        // Apply Ascend operation
        function applyAscend() {
            if (currentDepth >= L4) {
                logToConsole('A', `Maximum depth L_4 = ${L4} reached. Cannot ascend further.`);
                return;
            }

            currentDepth++;
            const coherence = (currentDepth / L4) * MU_C;
            logToConsole('A', `Ascend: ${currentDepth - 1} --> ${currentDepth} | mu = ${coherence.toFixed(6)}`);

            if (currentDepth === L4) {
                logToConsole('omega', `L_4-Helix reached! Coherence at mu_C = ${MU_C.toFixed(6)}`);
            }

            updateDisplay();
        }

        // Apply Descend operation (inverse)
        function applyDescend() {
            if (currentDepth <= 0) {
                logToConsole('D', 'Already at origin alpha. Cannot descend further.');
                return;
            }

            currentDepth--;
            const coherence = (currentDepth / L4) * MU_C;
            logToConsole('D', `Descend: ${currentDepth + 1} --> ${currentDepth} | mu = ${coherence.toFixed(6)}`);

            updateDisplay();
        }

        // Reset to origin
        function resetDepth() {
            currentDepth = 0;
            logToConsole('RESET', 'Returned to origin alpha (depth = 0)');
            updateDisplay();
        }

        // Auto-ascend animation
        function autoAscend() {
            if (animating) return;
            if (currentDepth >= L4) {
                logToConsole('AUTO', 'Already at maximum depth L_4');
                return;
            }

            animating = true;
            logToConsole('AUTO', 'Beginning automatic ascent to L_4...');

            const interval = setInterval(() => {
                if (currentDepth >= L4) {
                    clearInterval(interval);
                    animating = false;
                    logToConsole('AUTO', 'Automatic ascent complete. omega reached.');
                    return;
                }
                applyAscend();
            }, 500);
        }

        // Console logging
        function logToConsole(op, message) {
            const consoleEl = document.getElementById('console');
            const line = document.createElement('div');
            line.className = 'console-line';
            line.innerHTML = `<span class="console-prompt">ASCEND&gt;</span> <span style="color: #f59e0b;">${op}</span>: <span class="console-result">${message}</span>`;
            consoleEl.appendChild(line);
            consoleEl.scrollTop = consoleEl.scrollHeight;
        }

        // Initialize
        window.addEventListener('resize', resizeCanvas);

        initTreeLevels();
        resizeCanvas();
        updateDisplay();

        // Log initial formulas
        logToConsole('FORMULA', 'A: n --> n+1 (bounded by L_4 = 7)');
        logToConsole('INVERSE', 'A * D = D * A = Identity');
        logToConsole('COHERENCE', `mu_C = sqrt(3)/2 = ${MU_C.toFixed(10)}`);

        // ============================================
        // HELIX VISUALIZATION WITH ENERGY METER
        // ============================================

        const helixCanvas = document.getElementById('helixCanvas');
        const helixCtx = helixCanvas.getContext('2d');
        let helixLevel = 0;
        let helixAnimating = false;
        let helixRotation = 0;

        // Energy constants
        const PI_PHI = Math.PI * PHI;
        const DELTA_E = PI_PHI / L4;

        function resizeHelixCanvas() {
            helixCanvas.width = helixCanvas.offsetWidth;
            helixCanvas.height = helixCanvas.offsetHeight;
            drawHelix();
        }

        function drawHelix() {
            const w = helixCanvas.width;
            const h = helixCanvas.height;

            // Clear
            helixCtx.fillStyle = '#1a1a2e';
            helixCtx.fillRect(0, 0, w, h);

            const centerX = w / 2;
            const helixWidth = Math.min(w * 0.35, 200);
            const levelHeight = (h - 100) / (L4 + 1);

            // Draw helix structure
            for (let i = 0; i <= L4; i++) {
                const y = h - 50 - i * levelHeight;
                const angle = (i * Math.PI / 2) + helixRotation;

                // Left strand
                const leftX = centerX - helixWidth * 0.4 + Math.sin(angle) * helixWidth * 0.3;
                // Right strand
                const rightX = centerX + helixWidth * 0.4 - Math.sin(angle) * helixWidth * 0.3;

                // Draw horizontal connection at each level
                helixCtx.beginPath();
                helixCtx.moveTo(leftX, y);
                helixCtx.lineTo(rightX, y);
                helixCtx.strokeStyle = i <= helixLevel ? 'rgba(245, 158, 11, 0.6)' : 'rgba(255, 255, 255, 0.1)';
                helixCtx.lineWidth = i === helixLevel ? 3 : 1;
                helixCtx.stroke();

                // Level node
                const nodeX = centerX;
                const isActive = i === helixLevel;
                const isPast = i < helixLevel;

                helixCtx.beginPath();
                helixCtx.arc(nodeX, y, isActive ? 25 : 18, 0, Math.PI * 2);

                if (isActive) {
                    // Active level with glow
                    helixCtx.shadowColor = '#f59e0b';
                    helixCtx.shadowBlur = 25;
                    helixCtx.fillStyle = '#f59e0b';
                    helixCtx.fill();
                    helixCtx.shadowBlur = 0;

                    // Draw A symbol
                    helixCtx.fillStyle = '#0a0a0f';
                    helixCtx.font = 'bold 16px Courier New';
                    helixCtx.textAlign = 'center';
                    helixCtx.textBaseline = 'middle';
                    helixCtx.fillText('A', nodeX, y);
                } else if (isPast) {
                    helixCtx.fillStyle = 'rgba(245, 158, 11, 0.4)';
                    helixCtx.fill();
                    helixCtx.strokeStyle = '#f59e0b';
                    helixCtx.lineWidth = 2;
                    helixCtx.stroke();
                } else {
                    helixCtx.fillStyle = '#2a2a4e';
                    helixCtx.fill();
                    helixCtx.strokeStyle = '#444';
                    helixCtx.lineWidth = 1;
                    helixCtx.stroke();
                }

                // Level label
                helixCtx.fillStyle = isActive ? '#f59e0b' : '#666';
                helixCtx.font = isActive ? 'bold 12px Courier New' : '11px Courier New';
                helixCtx.textAlign = 'right';
                helixCtx.fillText(`z=${i}`, nodeX - 40, y + 4);

                // Energy label
                const levelEnergy = i * DELTA_E;
                helixCtx.textAlign = 'left';
                helixCtx.fillStyle = isPast || isActive ? '#22c55e' : '#444';
                helixCtx.fillText(`E=${levelEnergy.toFixed(2)}`, nodeX + 40, y + 4);

                // Draw vertical helix strands
                if (i < L4) {
                    const nextY = h - 50 - (i + 1) * levelHeight;
                    const nextAngle = ((i + 1) * Math.PI / 2) + helixRotation;
                    const nextLeftX = centerX - helixWidth * 0.4 + Math.sin(nextAngle) * helixWidth * 0.3;
                    const nextRightX = centerX + helixWidth * 0.4 - Math.sin(nextAngle) * helixWidth * 0.3;

                    // Left strand
                    helixCtx.beginPath();
                    helixCtx.moveTo(leftX, y);
                    helixCtx.quadraticCurveTo(leftX - 20, (y + nextY) / 2, nextLeftX, nextY);
                    helixCtx.strokeStyle = i < helixLevel ? 'rgba(245, 158, 11, 0.5)' : 'rgba(100, 100, 150, 0.2)';
                    helixCtx.lineWidth = 2;
                    helixCtx.stroke();

                    // Right strand
                    helixCtx.beginPath();
                    helixCtx.moveTo(rightX, y);
                    helixCtx.quadraticCurveTo(rightX + 20, (y + nextY) / 2, nextRightX, nextY);
                    helixCtx.stroke();
                }
            }

            // Draw energy meter on the left
            const meterX = 30;
            const meterY = 50;
            const meterHeight = h - 100;
            const meterWidth = 20;

            // Meter background
            helixCtx.fillStyle = '#1a1a2e';
            helixCtx.strokeStyle = '#444';
            helixCtx.lineWidth = 2;
            helixCtx.fillRect(meterX, meterY, meterWidth, meterHeight);
            helixCtx.strokeRect(meterX, meterY, meterWidth, meterHeight);

            // Energy fill
            const energyPercent = helixLevel / L4;
            const fillHeight = energyPercent * meterHeight;
            const gradient = helixCtx.createLinearGradient(0, meterY + meterHeight, 0, meterY);
            gradient.addColorStop(0, '#22c55e');
            gradient.addColorStop(0.5, '#f59e0b');
            gradient.addColorStop(1, '#ff6b35');
            helixCtx.fillStyle = gradient;
            helixCtx.fillRect(meterX + 2, meterY + meterHeight - fillHeight, meterWidth - 4, fillHeight);

            // Meter labels
            helixCtx.fillStyle = '#888';
            helixCtx.font = '10px Courier New';
            helixCtx.textAlign = 'center';
            helixCtx.fillText('E', meterX + meterWidth / 2, meterY - 10);
            helixCtx.fillText('max', meterX + meterWidth / 2, meterY + 15);
            helixCtx.fillText('0', meterX + meterWidth / 2, meterY + meterHeight + 15);

            // Draw complex plane rotation indicator on the right
            const planeX = w - 80;
            const planeY = h / 2;
            const planeRadius = 50;

            // Circle
            helixCtx.beginPath();
            helixCtx.arc(planeX, planeY, planeRadius, 0, Math.PI * 2);
            helixCtx.strokeStyle = '#444';
            helixCtx.lineWidth = 1;
            helixCtx.stroke();

            // Axes
            helixCtx.beginPath();
            helixCtx.moveTo(planeX - planeRadius - 5, planeY);
            helixCtx.lineTo(planeX + planeRadius + 5, planeY);
            helixCtx.moveTo(planeX, planeY + planeRadius + 5);
            helixCtx.lineTo(planeX, planeY - planeRadius - 5);
            helixCtx.strokeStyle = '#333';
            helixCtx.stroke();

            // Labels
            helixCtx.fillStyle = '#666';
            helixCtx.font = '10px Courier New';
            helixCtx.textAlign = 'center';
            helixCtx.fillText('Re', planeX + planeRadius + 12, planeY + 4);
            helixCtx.fillText('Im', planeX, planeY - planeRadius - 10);
            helixCtx.fillText('i', planeX + 10, planeY - planeRadius + 8);
            helixCtx.fillText('-i', planeX + 10, planeY + planeRadius - 2);

            // Rotation indicator
            const rotAngle = (helixLevel * Math.PI / 2);
            const indicatorX = planeX + Math.cos(-rotAngle + Math.PI/2) * (planeRadius - 5);
            const indicatorY = planeY - Math.sin(-rotAngle + Math.PI/2) * (planeRadius - 5);

            helixCtx.beginPath();
            helixCtx.moveTo(planeX, planeY);
            helixCtx.lineTo(indicatorX, indicatorY);
            helixCtx.strokeStyle = '#06b6d4';
            helixCtx.lineWidth = 3;
            helixCtx.stroke();

            helixCtx.beginPath();
            helixCtx.arc(indicatorX, indicatorY, 6, 0, Math.PI * 2);
            helixCtx.fillStyle = '#06b6d4';
            helixCtx.shadowColor = '#06b6d4';
            helixCtx.shadowBlur = 10;
            helixCtx.fill();
            helixCtx.shadowBlur = 0;

            // Rotation label
            helixCtx.fillStyle = '#06b6d4';
            helixCtx.font = '11px Courier New';
            helixCtx.textAlign = 'center';
            helixCtx.fillText(`${helixLevel * 90} deg`, planeX, planeY + planeRadius + 25);
            helixCtx.fillText('i-rotation', planeX, planeY + planeRadius + 38);

            // Alpha/Omega labels
            helixCtx.font = 'bold 14px Courier New';
            helixCtx.fillStyle = '#00ff88';
            helixCtx.fillText('alpha', centerX, h - 20);
            helixCtx.fillStyle = '#ff6b35';
            helixCtx.fillText('omega (L4)', centerX, 25);
        }

        function updateHelixDisplay() {
            const energy = helixLevel * DELTA_E;
            const rotation = helixLevel * 90;
            const percent = (helixLevel / L4) * 100;
            const entropyGrad = 1 / (L4 - helixLevel + 1);

            document.getElementById('helixLevel').textContent = helixLevel;
            document.getElementById('potentialEnergy').textContent = energy.toFixed(3);
            document.getElementById('rotationAngle').textContent = rotation + ' deg';
            document.getElementById('entropyGradient').textContent = (helixLevel < L4 ? '+' : '') + entropyGrad.toFixed(3);
            document.getElementById('energyPercent').textContent = percent.toFixed(1) + '%';
            document.getElementById('energyFill').style.width = percent + '%';

            drawHelix();
        }

        function helixAscend() {
            if (helixLevel >= L4) {
                logToConsole('HELIX', `Maximum level L4 = ${L4} reached. Cannot ascend further.`);
                return;
            }

            helixLevel++;
            helixRotation += Math.PI / 8;
            const energy = helixLevel * DELTA_E;
            logToConsole('HELIX-A', `Ascend: z=${helixLevel-1} --> z=${helixLevel} | E_A = ${energy.toFixed(4)} | theta = ${helixLevel * 90} deg`);

            if (helixLevel === L4) {
                logToConsole('OMEGA', `L4-Helix omega reached! Total energy E = pi*phi = ${PI_PHI.toFixed(6)}`);
            }

            updateHelixDisplay();
        }

        function helixDescend() {
            if (helixLevel <= 0) {
                logToConsole('HELIX', 'Already at origin alpha (z=0). Cannot descend further.');
                return;
            }

            helixLevel--;
            helixRotation -= Math.PI / 8;
            const energy = helixLevel * DELTA_E;
            logToConsole('HELIX-D', `Descend: z=${helixLevel+1} --> z=${helixLevel} | E_A = ${energy.toFixed(4)} | theta = ${helixLevel * 90} deg`);

            updateHelixDisplay();
        }

        function helixReset() {
            helixLevel = 0;
            helixRotation = 0;
            logToConsole('HELIX', 'Reset to origin alpha (z=0, E=0)');
            updateHelixDisplay();
        }

        function autoHelixClimb() {
            if (helixAnimating) return;
            if (helixLevel >= L4) {
                logToConsole('HELIX', 'Already at maximum level L4');
                return;
            }

            helixAnimating = true;
            logToConsole('AUTO-HELIX', 'Beginning automatic helix climb to L4...');

            const interval = setInterval(() => {
                if (helixLevel >= L4) {
                    clearInterval(interval);
                    helixAnimating = false;
                    logToConsole('AUTO-HELIX', `Climb complete. omega reached at E = ${PI_PHI.toFixed(4)}`);
                    return;
                }
                helixAscend();
            }, 600);
        }

        // Initialize helix
        window.addEventListener('resize', () => {
            resizeCanvas();
            resizeHelixCanvas();
        });

        resizeHelixCanvas();
        updateHelixDisplay();

        // Log cross-system info
        logToConsole('CROSS-SYS', 'A equiv depth++ equiv helix_climb equiv toward_OSC equiv i-rotation');
        logToConsole('ENERGY', `Delta_E per level = pi*phi/L4 = ${DELTA_E.toFixed(6)}`);
        logToConsole('S3', 'A^6 reveals full S3 symmetry: {e, (12), (13), (23), (123), (132)}');
    </script>
</body>
</html>
